###############################################################
# E/A#5 loader for E/A#5 - 8/21/2018
#
# Note: modified heavily for this Phoenix
#
# Fixed loader for another EA#5 program, use in tight memory
# constraints. Particularly tested for use with 4ADOS.
# -- based on --
# E/A#5 loader for Extended BASIC - 9/13/2013
# -- based on --
# E/A#5 loader for TI BASIC -- 26 Apr 09
# Uses scratchpad RAM to load anywhere in the 32k space
#
# Original by Mark Wills
# Tweaks by Mike Brent
# Support from the SWPB group, particularly Bill, Tim and Ben
#
# Limitations:
# - Maximum filename length, 64 characters
# - Maximum number of files, 10
# - Pretty much no error handling
#
# Usage:
# Use a binary file editor and inject the filename
# below the "----0x    <----" marks in the file. Do
# not change the width of the gap and pad with spaces.
# Do not attempt to use longer filenames than will fit.
#
# Will reset to master title page if FILE1 is not found
#
# Possible improvements:
# -Verify filename is 64 characters or less before using
#
###############################################################

VDPADR 	EQU 0x0000 			address to load the file(s) in vdp ram
VDPPAB 	EQU 0x2C00   		address of the first pab in vdp ram (10 PABs at 74 bytes each)
OPLOAD 	EQU 0x0500 			opcode for load operation for dsrlnk
VDPWA	EQU 0x8C02			VDP write address
VDPRD	EQU 0x8800			VDP read data
VDPWD	EQU 0x8C00			VDP write data
WS      EQU 0x8300          our workspace
    
    def FILENAME
    def EA5LD

###############################################
# now we dont even have XB to count on, so we need to provide the rest
# of the missing functions. Called with BL instead of BLWP
###############################################

# VDP multi byte write. r2 bytes from r1 to r0
VMBW
	ORI r0,0x4000	# set write flag
	SWPB r0			# little endian VDP
	MOVB r0,@VDPWA
	SWPB r0
	MOVB r0,@VDPWA	# address is set
	ANDI r0,0x3FFF	# restore (hopefully) the register
VMBWLP
	MOVB *r1+,@VDPWD
	DEC r2
	JNE VMBWLP
	B *r11

# VDP Single Byte Read. Read from r0 into r1 MSB
VSBR
	SWPB r0			# little endian VDP
	MOVB r0,@VDPWA
	SWPB r0
	MOVB r0,@VDPWA
	NOP				# delay after address write
	MOVB @VDPRD,r1	# get the byte
	B *r11

##########################################################
# DSRLNK Replacement - Editor/assembler adapted by Tursi #
# Its kind of unfortunate to have this AND the libti99 one...
##########################################################

DSRADR BSS 2
DSRCRU BSS 2
SAVE   BSS 2
NAMBUF BSS 8
NAMLEN BSS 2
DSRDAT DATA 0x2EAA

# Modified version of the E/A DSRLNK - pass address of PAB in r0
# BL instead BLWP, assumes DATA 0x8 	
EA3DSR
	   MOV r11,@SAVE
	   AI r0,9
	   MOV r0,@0x8356				Load the PAB pointer
A22B2  LI r5,8		                Get Data, should be 8 in the case I care about
#      SZCB @A20FC,15               Zero out the EQUAL bit in the return CPU status (ahh, I dont do this)
#      MOV  @0x8356,0			    Get PAB pointer into r0
       MOV  0,9						Copy to r9
       AI   9,-8                    pab status
       BL   @VSBR                   vsbr: read size (from r0 to MSB r1 - for DSK1.BLAH is 9)
       MOVB 1,3						copy to r3
       SRL  3,8						move into low byte (make a count)
       SETO 4						r4 = 0xffff
       LI   2,NAMBUF               	name buffer in r2
A22D0  INC  0						point to next byte of name (first byte on first pass)
       INC  4						increment r4 (becomes 0 on first pass)
       C    4,3						check if name finished
       JEQ  A22E4                  	Jump ahead if so
       BL   @VSBR                 	vsbr: copy character of name
       MOVB 1,*r2+                	copy 1 char into name buffer
       CB   1,@DSRDAT              	is it .?
       JNE  A22D0					no, loop around
A22E4  MOV  4,4						if we get here, we either got the whole length or a .
       JEQ  A238C                  	size=0, thats an error so skip out (no name to search)
       CI   4,0x0007					check against 7 characters (just the DSR name part)
       JGT  A238C                  	size0x7 is too long, so error out
       CLR  @0x83D0					clear the CRU base search
       MOV  4,@0x8354				length of the name (excluding .) goes into 0x8354
       MOV  4,@NAMLEN				also save it for later use
#       MOV  4,@0x2036               	also goes into 0x2036 (this is the official place)(not safe in XB)
       INC  4						add one to name length
       A    4,@0x8356				add to the PAB pointer (0x8356 points to the period!)
#       MOV  @0x8356,@0x2038          	save the pointer at 0x2038, too (not safe in XB)
       LWPI 0x83E0                  	Load GPLWS to call the DSR with
       CLR  1						r1=0
       LI   12,0x0F00				CRU base to 0x0F00 (first card -1)
       JMP  A2316				    skip card off (was a bug in the EA code?)
A2310  MOV  12,12					check base for 0
       JEQ  A2316					if not 0, skip card off. Looks like a bug, its never 0??
       SBZ  0                      	card off
A2316  AI   12,0x0100				next card (0x1000 for first)
       CLR  @0x83D0					clear CRU tracking at 0x83D0
       CI   12,0x2000				check if all cards are done
       JEQ  A2388                  	if yes, we didnt find it, so error out
       MOV  12,@0x83D0              	save cru base
       SBO  0                      	card on
       LI   2,0x4000					read card header bytes
       CB   *r2,@DSRDAT+1           	0xAA = header
       JNE  A2310                  	no: loop back for next card
       AI   r2,8            		offset (contains the DATA statement, so 8 for a device, for 0x4008)
       JMP  A2340					always jump into the loop from here
A233A  MOV  @0x83D2,2               	next sub
       SBO  0                      	card on (already is, isnt it??)
A2340  MOV  *r2,2                   	grab link pointer to next
       JEQ  A2310                  	If no pointer, link back to get next card
       MOV  2,@0x83D2               	save link address in 0x83D2
       INCT 2						point to entry address
       MOV  *r2+,9                  	save address in r9
       MOVB @0x8355,5				get DSR name length (low byte of 0x8354)
       JEQ  A2364                  	size=0, so take it 
       CB   5,*r2+					compare length to length in DSR
       JNE  A233A                  	diff size: loop back for next
       SRL  5,8						make length a word count
       LI   6,NAMBUF               	name buffer pointer in r6
A235C  CB   *r6+,*r2+                	check name
       JNE  A233A                  	diff name: loop back for next entry
       DEC  5						count down length
       JNE  A235C                  	not done yet: next char
A2364  INC  1                      	if we get here, everything matched, increment # calls
#       MOV  1,@0x203A              	save # of calls (not safe in XB)
       MOV  9,@DSRADR              	save address (move in XB for later)
       MOV  12,@DSRCRU             	save cru base (move in XB for later)
       BL   *r9                     	link
       JMP  A233A                  	check next entry on the same card -- most DSRs will skip this 
       SBZ  0                      	card off
       LWPI WS
       MOV  9,0
       BL   @VSBR	               	read pab status
       SRL  1,13					should be okay on Geneve?
       JNE  A238E                  	err
       CLR  r0						no err?
       MOV  @SAVE,r11
       B *r11
A2388  LWPI WS	                    errors
A238C  SETO 1                       flag error
A238E  SWPB 1
       MOVB r1,r0                   code in r0
#      SOCB @0x20FC,15               eq=1
       MOV @SAVE,r11
       B *r11

#################################
####### Entry point #############
#################################

EA5LD
		
# now we are going to precompute more PABs than we
# hopefully need! The idea is to save needing to update/
# rewrite the PABs in the scratchpad portion.
# For performance reasons, we dont examine the actual
# files at this point. Each PAB is 74 bytes.

# Get address of PABs last filename character in CPU into r5
		CLR r1 				prepare r1 for byte operations
		LI r5,PAB+9			address of start of filename - 1
		MOVB *r5,r1 		length byte in msb
		SWPB r1 			rotate into lsb
		A r1,r5 			add length to address. now pointing at last character

		LI r3,VDPPAB		Get first PAB address
		LI r4,10			Countdown number of PABs
DOLOAD
		MOV r3,r0	 		vdp ram address
		LI r1,PAB 			source address
		LI r2,74			copy pab (I use long filenames!)
		BL   @VMBW 			write to vdp ram
		
		AI r3,74			Next PAB target
		MOVB *r5,r1			Get filename last character
		AI r1,0x0100		Increment it (we dont care about the LSB)
		MOVB r1,*r5			Write it back
		DEC r4				Count down
		JNE DOLOAD			Copy next PAB

# now we load the first file into VDP
		LI r0,VDPPAB 		address of pab in vdp ram
# call the loader - first file is safe!
		BL @EA3DSR			tursis DSRLNK adaptation
		MOVB r0,r0			check for DSRLNK error
		JNE RESET
		
# check for error in load, reset if so
		LI r0,VDPPAB+1		address of the error byte in VDP
		BL   @VSBR			read it in
		MOVB r1,r1			Test the byte
		JEQ NOERR			all was well
RESET		
		BLWP @0x0000			reset console otherwise

NOERR		
# the file should now be in vdp ram at address vdpadr onwards

# now get the rest of our code into scratchpad RAM, so that we
# are safe no matter how much of the 32k is loaded. This means
# we give up the handy utility functions too

# copy two blocks to safe areas in scratchpad, per E/A page 404 and 405
		LI	r0,A8320
		LI 	r1,0x8320
		LI  r2,42
CP20	MOV *r0+,*r1+
		DECT r2
		JNE	CP20
		
		LI	r0,A8380
		LI 	r1,0x8380
		LI  r2,64
CP80	MOV *r0+,*r1+
		DECT r2
		JNE	CP80

# final chance to do initialization in large memory bank!
# All registers used:
# 0	- work				8 - VDPRD
# 1 - work				9 - Difference from next PAB to this error byte
# 2 - work				10- DSR Entry point
# 3 - work				11- BL return address
# 4 - work				12- name length for 0x8354
# 5 - size of PAB (0x40)	13- address of SBO 0 so we can NOP it for the final call
# 6 - start address		14- VDPSET in scratchpad
# 7 - VDP PAB pointer	15- BL second level return address

# Note that these scratch pad routines pretty much fill
# their alloted space - any changes will need to make room!
# When calling the DSR directly, we need to account for an additional
# 5 byte offset that DSRLNK is sneaking into the beginning. Since
# previous DSRs are done, it doesnt matter if those bytes are used.
# I need to explain the +5/+3 better so I can fix the real loader
		MOV @DSRCRU,@0x83F8	DSR CRU base, so we dont need DSRLNK again (GPLWS r12)
		MOV @DSRADR,r10		DSR entry point, so we dont need DSRLNK again
		MOV @NAMLEN,r12		DSR name length (to reload each call)
		LI r5,74			Size of PAB
		LI r7,VDPPAB+86		Second PAB (74), plus 9 for the filename length offset, plus 5 (BUT ONLY 3 HERE, cause PI. instead of DSK1.)
		LI r9,87			Distance back from next PAB to this error byte
		LI r13,0x83B2		address of SBO 0 - we clear it before the program jump
		LI r8,VDPRD			store some addresses in registers to reduce code size
		LI r14,VDPSET
		
# Its the first file, get the start address into r6
		LI r2,VDPADR+4 		address of VDP load address
		LI r1,0x8300+12 		target address r6
		LI r0,2 			2 bytes to read
		BL @TVMBR 			get the data
		
# jump into scratchpad and start to copy!
		B @0x8380
	
# Tag start of block
A8320

#		AORG 0x8320			(42 bytes available)
# VDP access utilities, so we dont rely on the EA ones being undisturbed
# need to use equates since the assembler isnt doing complex math right?

# Set VDP address in r2 for read			
VDPSET	EQU 0x8320
# Second label used by main RAM code during init
GVDPST
		SWPB r2				2
		MOVB r2,@VDPWA		4 6
		SWPB r2				8
		MOVB r2,@VDPWA		10 12
		B *r11				14

# Get header - read the 6 byte header from VDP into r2,r3,r4
GETHDR	EQU 0x832E
		LI r2,VDPADR		16 18	Reading from the VDP buffer
		LI r1,0x8300+4		20 22	Reading into r2,r3,r4 (Yes, we can overwrite VDP adr)
		LI r0,6				24 26	Get 6 bytes
# instead of branching, we can just fall through now into tvmbr

# Tiny multi-byte read - r0=count, r1=CPU address, r2=VDP Address (nonstandard!)
# This odd order is used so we can use the header data more directly
# r1,r0 destroyed 		
TVMBR	EQU	0x833A
		MOV r11,r15			28
		BL *r14				30
LP1		MOVB *r8,*r1+		32
		DEC r0				34
		JNE LP1				36
		
# these moves are only useful to GETHDR, but should
# not harm anything else, since r0 and r1 are scratch
# this just gives us a little more space in the other block
		MOV r3,r0			38 		byte count for gethdr
		MOV r4,r1			40		set CPU address for gethdr

# now back to caller		
		B *r15				42
		
# Tag start of block
A8380

#		AORG 0x8380			(64 bytes available)
# At this point, we have data in VDP, ready to go
# get the first three words of data from vdp, which tell us
# how to handle the data
# word 0 (r2)=eof file indicator (0=no more files to load)
# word 1 (r3)=length of data in bytes
# word 2 (r4)=destination address in cpu ram
# well read them directly into registers, just to be clever :-)
CPYLP
		BL @GETHDR			2 4

# r2 contains the next flag, so preserve that
# we now have all the info we need to copy the loaded data to
# cpu ram. GetHdr moved r3 and r4 for us already.
NEXT
#		MOV r3,r0					Byte count
		MOV r2,r3			6		Save next flag
#		MOV	r4,r1					Set CPU address
		LI r2,VDPADR+6		8  10	Set next VDP address
		BL @TVMBR			12 14	tvmbr

# see if any more files are required
		MOV r3,r3 			16		check flag
		JNE NOGO 			18		if not 0 then skip ahead

# loads r13 with a SWPB r2 - harmless replacement for SBO 0
		MOV *r14,*r13		28		
		
# clear lower PAB, some apps (like Munchman) assume bytes are zeroed
		MOV r14,r0			20 		First code block, we have to skip workspace

#		#LI r2,41			
# we will count with r9 instead, which contains "87" for the PAB count. Well count
# down by two but only clear 1, which will loop for 44 bytes, clearing
# two extra bytes (which is in the temp stack area and should be safe)
# we also take advantage of knowing the MSB of r9 is zeroed
CLRPAB
#		CLR *r0+			
		MOVB r9,*r0+		22
#		DECT r2				
		DECT r9				24
		JOC CLRPAB			26
		
		MOV r6,r10			30		load program jump address to r10 (was DSR address)
		JMP GPLJMP			32		load GPLWS and branch (even though its BL, thats ok)

# else more files are required
NOGO
# now we need to do a smaller version of DSRLNK that merely calls the last entry point
# note that this code assumes that 0x8354 (containing the DSR name length) is unmodified!
		MOV r7,@0x8356		34 36	address of filename period
		MOV r12,@0x8354		38 40	length of DSR name
		A r5,r7				42		Point to next PAB
GPLJMP	MOV r10,@0x83F2		44 46	copy address into GPLWS r9
		LWPI 0x83E0			48 50	load GPLWS to protect ours
		SBO 0				52		turn on the DSR card - nopd in final call (equ 0x83B2 for r13)
		BL  *r9				54		call same DSR again (also branch to program)
		NOP					56		DSRs usually skip this on success
		SBZ 0				58		turn off the DSR card
		LWPI 0x8300			60 62	restore our workspace
		JMP CPYLP			64		go back and do the copy again, if no error

PAB
		DATA OPLOAD 		opcode for load
		DATA VDPADR 		destination address in vdp
		DATA 0x0000 		not required for load operation
		DATA 8198 			max number of bytes to load
		DATA 0x002a 		last byte=length byte <<<
FILENAME
# warning: the length of this string for patching is hardcoded in engine.cpp (setting the index)
# and also the length byte in the PAB above
		TEXT 'PI.HTTP://harmle'
		TEXT 'sslion.com/phoen'
		TEXT 'ix/PLOC001      '
		
		END
