###############################################################
# E/A#5 loader for E/A#5 - 8/21/2018
#
# Note: modified heavily for this Phoenix
#
# Fixed loader for another EA#5 program, use in tight memory
# constraints. Particularly tested for use with 4ADOS.
# -- based on --
# E/A#5 loader for Extended BASIC - 9/13/2013
# -- based on --
# E/A#5 loader for TI BASIC -- 26 Apr 09
# Uses scratchpad RAM to load anywhere in the 32k space
#
# Original by Mark Wills
# Tweaks by Mike Brent
# Support from the SWPB group, particularly Bill, Tim and Ben
#
# Limitations:
# - Maximum filename length, 64 characters
# - Maximum number of files, 10
# - Pretty much no error handling
#
# Usage:
# Use a binary file editor and inject the filename
# below the "----0x    <----" marks in the file. Do
# not change the width of the gap and pad with spaces.
# Do not attempt to use longer filenames than will fit.
#
# Will reset to master title page if FILE1 is not found
#
# Possible improvements:
# -Verify filename is 64 characters or less before using
#
###############################################################

VDPADR 	EQU 0x0000 			address to load the file(s) in vdp ram
VDPPAB 	EQU 0x2C00   		address of the first pab in vdp ram (10 PABs at 74 bytes each)
OPLOAD 	EQU 0x0500 			opcode for load operation for dsrlnk
VDPWA	EQU 0x8C02			VDP write address
VDPRD	EQU 0x8800			VDP read data
VDPWD	EQU 0x8C00			VDP write data
WS      EQU 0x8300          our workspace
    
    def FILENAME
    def EA5LD
    ref dsrlnkraw

###############################################
# now we dont even have XB to count on, so we need to provide the rest
# of the missing functions. Called with BL instead of BLWP
###############################################

# VDP multi byte write. r2 bytes from r1 to r0
VMBW
	ORI r0,0x4000	# set write flag
	SWPB r0			# little endian VDP
	MOVB r0,@VDPWA
	SWPB r0
	MOVB r0,@VDPWA	# address is set
	ANDI r0,0x3FFF	# restore (hopefully) the register
VMBWLP
	MOVB *r1+,@VDPWD
	DEC r2
	JNE VMBWLP
	B *r11

# VDP Single Byte Read. Read from r0 into r1 MSB
VSBR
	SWPB r0			# little endian VDP
	MOVB r0,@VDPWA
	SWPB r0
	MOVB r0,@VDPWA
	NOP				# delay after address write
	MOVB @VDPRD,r1	# get the byte
	B *r11

##########################################################
# DSRLNK Replacement - Editor/assembler adapted by Tursi #
# Its kind of unfortunate to have this AND the libti99 one...
##########################################################

DSRADR BSS 2
DSRCRU BSS 2
SAVE   BSS 2
SAVE2  BSS 2
NAMLEN BSS 2
DSRDAT DATA 0x2EAA

#################################
####### Entry point #############
#################################

## NOTE: THis hacked version expects a 2 char device name (PI) and
## calls out to dsrlnkraw from libti99

EA5LD
		
# now we are going to precompute more PABs than we
# hopefully need! The idea is to save needing to update/
# rewrite the PABs in the scratchpad portion.
# For performance reasons, we dont examine the actual
# files at this point. Each PAB is 74 bytes.
        MOV R11,@SAVE2

# Get address of PABs last filename character in CPU into r5
		CLR r1 				prepare r1 for byte operations
		LI r5,PAB+9			address of start of filename - 1
		MOVB *r5,r1 		length byte in msb
		SWPB r1 			rotate into lsb
		A r1,r5 			add length to address. now pointing at last character

		LI r3,VDPPAB		Get first PAB address
		LI r4,10			Countdown number of PABs
DOLOAD
		MOV r3,r0	 		vdp ram address
		LI r1,PAB 			source address
		LI r2,74			copy pab (I use long filenames!)
		BL   @VMBW 			write to vdp ram
		
		AI r3,74			Next PAB target
		MOVB *r5,r1			Get filename last character
		AI r1,0x0100		Increment it (we dont care about the LSB)
		MOVB r1,*r5			Write it back
		DEC r4				Count down
		JNE DOLOAD			Copy next PAB

# now we load the first file into VDP
# call the loader - first file is safe!
#		LI r0,VDPPAB 		address of pab in vdp ram
#		BL @EA3DSR			tursis DSRLNK adaptation
#		MOVB r0,r0			check for DSRLNK error

# some tweaks to use the libti99 DSRLNK, since it's already loaded
		LI r1,VDPPAB 		address of pab in vdp ram
        BL @dsrlnkraw       libti99 DSRLNK
        MOVB R1,R1          check return
		JNE RESET

        LI r1,2             We know its "PI."
        mov r1,@NAMLEN
        MOV  @>83F2,@DSRADR     save address (move in XB for later)
        MOV  @>83D0,@DSRCRU     save cru base (move in XB for later)
		
# check for error in load, reset if so
		LI r0,VDPPAB+1		address of the error byte in VDP
		BL   @VSBR			read it in
		MOVB r1,r1			Test the byte
		JEQ NOERR			all was well
RESET		
#		BLWP @0x0000			reset console otherwise
# we might be able to return...
        mov @SAVE2,r11
        b *r11

NOERR		
# the file should now be in vdp ram at address vdpadr onwards

# now get the rest of our code into scratchpad RAM, so that we
# are safe no matter how much of the 32k is loaded. This means
# we give up the handy utility functions too

# copy two blocks to safe areas in scratchpad, per E/A page 404 and 405
		LI	r0,A8320
		LI 	r1,0x8320
		LI  r2,42
CP20	MOV *r0+,*r1+
		DECT r2
		JNE	CP20
		
		LI	r0,A8380
		LI 	r1,0x8380
		LI  r2,64
CP80	MOV *r0+,*r1+
		DECT r2
		JNE	CP80

# final chance to do initialization in large memory bank!
# All registers used:
# 0	- work				8 - VDPRD
# 1 - work				9 - Difference from next PAB to this error byte
# 2 - work				10- DSR Entry point
# 3 - work				11- BL return address
# 4 - work				12- name length for 0x8354
# 5 - size of PAB (0x40)	13- address of SBO 0 so we can NOP it for the final call
# 6 - start address		14- VDPSET in scratchpad
# 7 - VDP PAB pointer	15- BL second level return address

# Note that these scratch pad routines pretty much fill
# their alloted space - any changes will need to make room!
# When calling the DSR directly, we need to account for an additional
# 5 byte offset that DSRLNK is sneaking into the beginning. Since
# previous DSRs are done, it doesnt matter if those bytes are used.
# I need to explain the +5/+3 better so I can fix the real loader
		MOV @DSRCRU,@0x83F8	DSR CRU base, so we dont need DSRLNK again (GPLWS r12)
		MOV @DSRADR,r10		DSR entry point, so we dont need DSRLNK again
		MOV @NAMLEN,r12		DSR name length (to reload each call)
		LI r5,74			Size of PAB
		LI r7,VDPPAB+86		Second PAB (74), plus 9 for the filename length offset, plus 5 (BUT ONLY 3 HERE, cause PI. instead of DSK1.)
		LI r9,87			Distance back from next PAB to this error byte
		LI r13,0x83B2		address of SBO 0 - we clear it before the program jump
		LI r8,VDPRD			store some addresses in registers to reduce code size
		LI r14,VDPSET
		
# Its the first file, get the start address into r6
		LI r2,VDPADR+4 		address of VDP load address
		LI r1,0x8300+12 		target address r6
		LI r0,2 			2 bytes to read
		BL @TVMBR 			get the data
		
# jump into scratchpad and start to copy!
		B @0x8380
	
# Tag start of block
A8320

#		AORG 0x8320			(42 bytes available)
# VDP access utilities, so we dont rely on the EA ones being undisturbed
# need to use equates since the assembler isnt doing complex math right?

# Set VDP address in r2 for read			
VDPSET	EQU 0x8320
# Second label used by main RAM code during init
GVDPST
		SWPB r2				2
		MOVB r2,@VDPWA		4 6
		SWPB r2				8
		MOVB r2,@VDPWA		10 12
		B *r11				14

# Get header - read the 6 byte header from VDP into r2,r3,r4
GETHDR	EQU 0x832E
		LI r2,VDPADR		16 18	Reading from the VDP buffer
		LI r1,0x8300+4		20 22	Reading into r2,r3,r4 (Yes, we can overwrite VDP adr)
		LI r0,6				24 26	Get 6 bytes
# instead of branching, we can just fall through now into tvmbr

# Tiny multi-byte read - r0=count, r1=CPU address, r2=VDP Address (nonstandard!)
# This odd order is used so we can use the header data more directly
# r1,r0 destroyed 		
TVMBR	EQU	0x833A
		MOV r11,r15			28
		BL *r14				30
LP1		MOVB *r8,*r1+		32
		DEC r0				34
		JNE LP1				36
		
# these moves are only useful to GETHDR, but should
# not harm anything else, since r0 and r1 are scratch
# this just gives us a little more space in the other block
		MOV r3,r0			38 		byte count for gethdr
		MOV r4,r1			40		set CPU address for gethdr

# now back to caller		
		B *r15				42
		
# Tag start of block
A8380

#		AORG 0x8380			(64 bytes available)
# At this point, we have data in VDP, ready to go
# get the first three words of data from vdp, which tell us
# how to handle the data
# word 0 (r2)=eof file indicator (0=no more files to load)
# word 1 (r3)=length of data in bytes
# word 2 (r4)=destination address in cpu ram
# well read them directly into registers, just to be clever :-)
CPYLP
		BL @GETHDR			2 4

# r2 contains the next flag, so preserve that
# we now have all the info we need to copy the loaded data to
# cpu ram. GetHdr moved r3 and r4 for us already.
NEXT
#		MOV r3,r0					Byte count
		MOV r2,r3			6		Save next flag
#		MOV	r4,r1					Set CPU address
		LI r2,VDPADR+6		8  10	Set next VDP address
		BL @TVMBR			12 14	tvmbr

# see if any more files are required
		MOV r3,r3 			16		check flag
		JNE NOGO 			18		if not 0 then skip ahead

# loads r13 with a SWPB r2 - harmless replacement for SBO 0
		MOV *r14,*r13		28		
		
# clear lower PAB, some apps (like Munchman) assume bytes are zeroed
		MOV r14,r0			20 		First code block, we have to skip workspace

#		#LI r2,41			
# we will count with r9 instead, which contains "87" for the PAB count. Well count
# down by two but only clear 1, which will loop for 44 bytes, clearing
# two extra bytes (which is in the temp stack area and should be safe)
# we also take advantage of knowing the MSB of r9 is zeroed
CLRPAB
#		CLR *r0+			
		MOVB r9,*r0+		22
#		DECT r2				
		DECT r9				24
		JOC CLRPAB			26
		
		MOV r6,r10			30		load program jump address to r10 (was DSR address)
		JMP GPLJMP			32		load GPLWS and branch (even though its BL, thats ok)

# else more files are required
NOGO
# now we need to do a smaller version of DSRLNK that merely calls the last entry point
# note that this code assumes that 0x8354 (containing the DSR name length) is unmodified!
		MOV r7,@0x8356		34 36	address of filename period
		MOV r12,@0x8354		38 40	length of DSR name
		A r5,r7				42		Point to next PAB
GPLJMP	MOV r10,@0x83F2		44 46	copy address into GPLWS r9
		LWPI 0x83E0			48 50	load GPLWS to protect ours
		SBO 0				52		turn on the DSR card - nopd in final call (equ 0x83B2 for r13)
		BL  *r9				54		call same DSR again (also branch to program)
		NOP					56		DSRs usually skip this on success
		SBZ 0				58		turn off the DSR card
		LWPI 0x8300			60 62	restore our workspace
		JMP CPYLP			64		go back and do the copy again, if no error

PAB
		DATA OPLOAD 		opcode for load
		DATA VDPADR 		destination address in vdp
		DATA 0x0000 		not required for load operation
		DATA 8198 			max number of bytes to load
		DATA 0x002a 		last byte=length byte <<<
FILENAME
# warning: the length of this string for patching is hardcoded in engine.cpp (setting the index)
# and also the length byte in the PAB above
		TEXT 'PI.HTTP://harmle'
		TEXT 'sslion.com/phoen'
		TEXT 'ix/PLOC001      '
		
		END
