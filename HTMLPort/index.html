<!DOCTYPE html>
<!-- Tursilion releases this code to Public Domain - you may use it for your own games if you find it useful. -->
<!-- If you make useful fixes, though, why not offer them back? -->
<!-- https://github.com/tursilion/turnabout -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phoenix Wright: Turnabout Storm</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: monospace;
            color: #fff;
            overflow: hidden;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            background-color: #000;
        }

        #imageArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 66.67%; /* top 2/3 for graphics */
            background-color: #000;
            overflow: hidden;
        }

        #gameImage {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            background-color: #111;
        }

        #textArea {
            position: absolute;
            bottom: 60px; /* Space for button bar */
            left: 0;
            width: 100%;
            height: calc(33.33% - 60px); /* bottom 1/3 minus button bar */
            background-color: #000;
            border-top: 2px solid #333;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        #buttonBar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background-color: #222;
            border-top: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .game-button {
            background-color: #444;
            color: #fff;
            border: 2px solid #666;
            border-radius: 5px;
            padding: 8px 16px;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            min-width: 80px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .game-button:hover:not(.disabled) {
            background-color: #555;
            border-color: #888;
            transform: translateY(-1px);
        }

        .game-button:active:not(.disabled) {
            transform: translateY(0px);
            background-color: #333;
        }

        .game-button.disabled {
            background-color: #222;
            color: #666;
            border-color: #333;
            cursor: not-allowed;
        }

        .game-button.highlighted {
            background-color: #006;
            border-color: #44f;
        }

        #nameDisplay {
            color: #4af;
            background-color: #333;
            padding: 4px 8px;
            margin-bottom: 8px;
            display: none;
            border-radius: 4px;
            font-size: 24px;
        }

        #textDisplay {
            color: #eee;
            line-height: 1.4;
            min-height: 100px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 24px;
        }

        #sprites {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #ff0;
            font-size: 16px;
            letter-spacing: 2px;
        }

        #investigationCursor {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid #ff0;
            background-color: rgba(255, 255, 0, 0.3);
            display: none;
            pointer-events: none;
        }

        #missesDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #f44;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
        }

        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #fff;
            padding: 20px;
            min-width: 300px;
            display: none;
        }

        #evidenceMenu {
            position: absolute;
            top: 33vh; /* Center vertically at 33% from top */
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            max-height: 66.67vh; /* Limit to top 2/3rds of screen */
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid #fff;
            padding: 20px;
            box-sizing: border-box;
        }

        #evidenceMenu h3 {
            margin-top: 0;
            color: #fff;
        }

        .menu-item {
            padding: 10px;
            cursor: pointer;
            border: 1px solid #333;
            margin: 5px 0;
            background-color: #222;
        }

        .menu-item:hover {
            background-color: #444;
        }

        .menu-item.selected {
            background-color: #006;
            border-color: #44f;
        }

        .menu-item.read {
            background-color: #333;
            color: #aaa;
        }

        .menu-item:focus {
            outline: 2px solid #44f;
            outline-offset: -2px;
            background-color: #444;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loadingScreen">Loading Phoenix Wright: Turnabout Storm...</div>

        <div id="imageArea">
            <img id="gameImage" src="" alt="Game Scene" style="display: none;">
            <div id="investigationCursor"></div>
        </div>

        <div id="textArea">
            <div id="nameDisplay"></div>
            <div id="textDisplay"></div>
            <div id="sprites"></div>
        </div>

        <div id="missesDisplay">Misses: <span id="missesCount">0</span></div>

        <div id="evidenceMenu" class="menu">
            <h3>Evidence</h3>
            <div id="evidenceList"></div>
            <div id="evidenceCloseButton" class="menu-item" tabindex="0" onclick="game.closeEvidence()" style="margin-top: 15px;">Close Evidence</div>
        </div>

        <div id="evidenceDetail" class="menu" style="max-width: 600px;">
            <h3 id="evidenceDetailName">Evidence Name</h3>
            <div id="evidenceDetailDescription"></div>
            <div id="evidenceDetailButtons">
                <div class="menu-item" id="presentEvidenceBtn" onclick="game.presentEvidence()" style="display: none;">Present Evidence</div>
                <div class="menu-item" onclick="game.closeEvidenceDetail()">Back to Evidence List</div>
            </div>
        </div>

        <div id="conversationMenu" class="menu">
            <h3>Talk</h3>
            <div id="conversationList"></div>
        </div>

        <div id="mainMenu" class="menu">
            <h3>Phoenix Wright: Turnabout Storm</h3>
            <div class="menu-item" onclick="game.startNew()">1. Start New Game</div>
            <div class="menu-item" onclick="game.loadGame()">2. Load Game</div>
            <div class="menu-item" onclick="game.showCredits()">3. Credits</div>
        </div>

        <div id="cheatMenu" class="menu">
            <h3>Cheat Menu - Select Location</h3>
            <div id="cheatLocationList"></div>
            <div class="menu-item" tabindex="0" onclick="game.closeCheatMenu()" style="margin-top: 15px;">Close</div>
        </div>

        <div id="fileMenu" class="menu">
            <h3>File</h3>
            <div class="menu-item" tabindex="0" onclick="game.saveGame()">Save Game</div>
            <div class="menu-item" tabindex="0" onclick="game.loadGame()">Load Game</div>
            <div class="menu-item" tabindex="0" onclick="game.showMainMenu()">Main Menu</div>
            <div class="menu-item" tabindex="0" onclick="game.closeFileMenu()">Close</div>
        </div>

        <div id="buttonBar">
            <button id="nextBtn" class="game-button" onclick="game.nextButton()">Next</button>
            <button id="evidenceBtn" class="game-button" onclick="game.evidenceButton()">Evidence</button>
            <button id="pressBtn" class="game-button" onclick="game.pressButton()">Press</button>
            <button id="objectionBtn" class="game-button" onclick="game.objectionButton()">Objection</button>
            <button id="leftBtn" class="game-button" onclick="game.leftButton()">&lt;</button>
            <button id="rightBtn" class="game-button" onclick="game.rightButton()">&gt;</button>
            <button id="fileBtn" class="game-button" onclick="game.fileButton()">File</button>
        </div>
    </div>

    <script>
        // Constants from structures.h
        const PP_FIRST = 0x8000;
        const PP_MAX = 18;

        // Evidence constants (python updateEnums.py ../structures.h structures.js)
        const EV_NONE = 0;
        const EV_BADGE = 1;
        const EV_MAGATAMA = 2;
        const EV_FILLIES = 3;
        const EV_E_BADGE = 4;
        const EV_EQ500 = 5;
        const EV_EVERFREE = 6;
        const EV_PHOTO1 = 7;
        const EV_BURNT = 8;
        const EV_PHOTO2 = 9;
        const EV_FEATHER = 10;
        const EV_AUTOPSY = 11;
        const EV_CRIMESCENE = 12;
        const EV_WEATHER = 13;
        const EV_CLOUDREPORT = 14;
        const EV_PICTURES = 15;
        const EV_BLACKMAIL = 16;
        const EV_ACEKEY = 17;
        const EV_TORNRESIGN = 18;
        const EV_UNICORNSPELL = 19;
        const EV_LIST = 20;
        const EV_START_INTERNAL = 21;
        const EV_I_QUESTIONCLOUD = 22;
        const EV_I_IN1FLAG1 = 23;
        const EV_I_WHINEBED = 24;
        const EV_I_WHINEBREAKFAST = 25;
        const EV_I_DAY1DESPERATE = 26;
        const EV_I_FLUTTERANIMALS = 27;
        const EV_MAX_STORED_EV = 28;
        const EV_I_0 = 29;
        const EV_I_1 = 30;
        const EV_I_2 = 31;
        const EV_I_3 = 32;
        const EV_I_4 = 33;
        const EV_I_5 = 34;
        const EV_I_6 = 35;
        const EV_I_7 = 36;
        const EV_I_SEARCH_LEFT = 37;
        const EV_I_SEARCH_RIGHT = 38;
        const EV_START_TAGS = 39;
        const EV_T_SNDBCK = 40;
        const EV_T_SNDBCK2 = 41;
        const EV_T_WHORU = 42;
        const EV_T_CRIME = 43;
        const EV_T_DETAIL = 44;
        const EV_T_HUMAN = 45;
        const EV_T_NOHUMAN = 46;
        const EV_T_LAWYERBADGE = 47;
        const EV_T_NOBADGE = 48;
        const EV_T_RIGHTBADGE = 49;
        const EV_T_QUESTIONBADGE = 50;
        const EV_T_NOQBADGE = 51;
        const EV_T_CONCERN = 52;
        const EV_T_NOCONCERN = 53;
        const EV_T_RDNAME = 54;
        const EV_T_EARTHP = 55;
        const EV_T_UNIP = 56;
        const EV_T_PEGASUSP = 57;
        const EV_T_NOPONY = 58;
        const EV_T_BADGUESS = 59;
        const EV_T_ACE = 60;
        const EV_T_EQ500 = 61;
        const EV_T_DONTWORRY = 62;
        const EV_T_HOWDIE = 63;
        const EV_T_BELIEVE = 64;
        const EV_T_ARREST = 65;
        const EV_T_MAKESURE = 66;
        const EV_T_CHECKDASH = 67;
        const EV_T_WHYTHERE = 68;
        const EV_T_FSEE = 69;
        const EV_T_FBEG = 70;
        const EV_T_FWORK = 71;
        const EV_T_INVEST = 72;
        const EV_T_DARK = 73;
        const EV_T_IN1_SC1 = 74;
        const EV_T_I11_4 = 75;
        const EV_T_I11_5 = 76;
        const EV_T_I11_NOTHING = 77;
        const EV_T_IN1_SC2 = 78;
        const EV_T_I12_4 = 79;
        const EV_T_I12_NOTHING = 80;
        const EV_T_IN1_SC3 = 81;
        const EV_T_IN1_SC3b = 82;
        const EV_T_I13_7 = 83;
        const EV_T_I13_NOTHING = 84;
        const EV_T_IN1_DONE = 85;
        const EV_T_ISMAGIC = 86;
        const EV_T_ABOUTACE = 87;
        const EV_T_HOWDO = 88;
        const EV_T_RD500 = 89;
        const EV_T_BED = 90;
        const EV_T_BREAKFAST = 91;
        const EV_T_NERVOUS = 92;
        const EV_T_WHINING = 93;
        const EV_T_TELLRD = 94;
        const EV_T_ASKTS = 95;
        const EV_T_WHOTRIX = 96;
        const EV_T_KNOWTRIX = 97;
        const EV_T_TRIXGRUDGE = 98;
        const EV_T_COURT = 99;
        const EV_T_EVIDENCE = 100;
        const EV_T_YESMAG = 101;
        const EV_T_NOMAG = 102;
        const EV_T_ALLMAG = 103;
        const EV_T_ASKHELP = 104;
        const EV_T_WINGIT = 105;
        const EV_T_OBJCLOUD = 106;
        const EV_T_ACCCLOUD = 107;
        const EV_T_WHOCALLED = 108;
        const EV_T_ABCLOUD = 109;
        const EV_T_3RDBOLT = 110;
        const EV_T_SUREBOLT = 111;
        const EV_P_ZECORA = 112;
        const EV_P_WALKHOME = 113;
        const EV_P_LIGHT840 = 114;
        const EV_P_WENTHOME = 115;
        const EV_P_BUMPED = 116;
        const EV_P_OUTSIDE = 117;
        const EV_O_BADBLOOM = 118;
        const EV_O_BADBLOOM2 = 119;
        const EV_O_BADBLOOM3 = 120;
        const EV_O_GOODBLOOM = 121;
        const EV_T_BLOOMTEST = 122;
        const EV_T_BLOOMCROSS = 123;
        const EV_T_BLOOMCROSS2 = 124;
        const EV_T_PRESEF = 125;
        const EV_T_PRESSBLOOM = 126;
        const EV_T_NOPRESSBL = 127;
        const EV_T_WHATCUTIE = 128;
        const EV_T_NOCUTIE = 129;
        const EV_T_LOOPBLOOM = 130;
        const EV_T_FEEL = 131;
        const EV_T_REACT = 132;
        const EV_T_YESFOOL = 133;
        const EV_T_NOFOOL = 134;
        const EV_T_YESSCHED = 135;
        const EV_T_NOSCHED = 136;
        const EV_T_QMOTIVE = 137;
        const EV_T_PTHEORY = 138;
        const EV_T_TRIXIECROSS1 = 139;
        const EV_P_RDEVERFREE = 140;
        const EV_P_RDSEEACE = 141;
        const EV_P_RDZAPACE = 142;
        const EV_O_GOODTRIXIE1 = 143;
        const EV_O_BADTRIXIE1 = 144;
        const EV_T_SHOWEATHER = 145;
        const EV_T_WETLOOP = 146;
        const EV_T_YESAPONY = 147;
        const EV_T_NOAPONY = 148;
        const EV_T_WHYSHOW = 149;
        const EV_T_WHYHAVE = 150;
        const EV_P_FNIGHTCHICKENS = 151;
        const EV_P_FLIGHTNING = 152;
        const EV_P_FSAWDASH = 153;
        const EV_P_FNOFOLLOW = 154;
        const EV_P_FPOLICE = 155;
        const EV_P_FNOTHINGELSE = 156;
        const EV_O_GOODFLUT = 157;
        const EV_O_BADFLUT = 158;
        const EV_O_BADFLUT2 = 159;
        const EV_T_FLUTTEST = 160;
        const EV_T_FLUTCROSS = 161;
        const EV_T_FLUTCROSS2 = 162;
        const EV_T_FHARDWORK = 163;
        const EV_T_FHOWLONG = 164;
        const EV_T_FCORRECTL = 165;
        const EV_T_FNOCORRECTL = 166;
        const EV_T_FGOTANIMALS = 167;
        const EV_T_FSEEAB = 168;
        const EV_T_FSEEPW = 169;
        const EV_T_FSEETS = 170;
        const EV_T_FSEERD = 171;
        const EV_T_LOOPFWHO = 172;
        const EV_T_SKIPSUIT = 173;
        const EV_T_NOSKIPSUIT = 174;
        const EV_T_LOOPFWHO2 = 175;
        const EV_T_FACCFS = 176;
        const EV_T_FACCTR = 177;
        const EV_T_FACCRD = 178;
        const EV_T_JUDGERETRY = 179;
        const EV_T_LOOPFSHOW = 180;
        const EV_T_FFEATHER = 181;
        const EV_T_FMISSOUT = 182;
        const EV_T_LOOPFSND = 183;
        const EV_T_FBOLT2 = 184;
        const EV_T_FQ1 = 185;
        const EV_T_FQ2 = 186;
        const EV_T_FQ3 = 187;
        const EV_T_FFINALMISS = 188;

        // Investigation bitflags
        const IV_CELL0 = 1;
        const IV_CELL1 = 2;
        const IV_CELL2 = 4;
        const IV_CELL3 = 8;
        const IV_CELL4 = 0x10;
        const IV_CELL5 = 0x20;
        const IV_CELL6 = 0x40;
        const IV_CELL7 = 0x80;
        const IV_LEFTOK = 0x100;
        const IV_RIGHTOK = 0x200;

        // People constants
        const PP_NONE = 0x8000;
        const PP_UNKNOWN = 0x8100;
        const PP_PHOENIX = 0x8200;
        const PP_TWILIGHT = 0x8300;
        const PP_GUARD = 0x8400;
        const PP_RAINBOW = 0x8500;
        const PP_ACE2 = 0x8600;
        const PP_ACE = 0x8700;
        const PP_FLUTTERSHY = 0x8800;
        const PP_TRIXIE = 0x8900;
        const PP_JUDGE = 0x8a00;
        const PP_BLOOM = 0x8b00;
        const PP_PINKIE = 0x8c00;
        const PP_SONATA = 0x8d00;
        const PP_EDGEWORTH = 0x8e00;
        const PP_TESTIMONY = 0x8f00;
        const PP_CROSSEXAM = 0x9000;
        const PP_GALLERY = 0x9100;

        // Command constants (from structures.h)
        const CMD_NONE = 0;
        const CMD_FLASH = 1;
        const CMD_BLACK = 2;
        const CMD_WHITE = 3;
        const CMD_STOPMUS = 4;
        const CMD_MISS = 5;
        const CMD_CLEARMISS = 6;
        const CMD_STOREMISS = 7;
        const CMD_RECALLMISS = 8;
        const CMD_CLEARTEST = 9;

        // SFX Commands
        const CMD_HAMMERSFX = 10;
        const CMD_CHIMESFX = 11;
        const CMD_BOOMSFX = 12;
        const CMD_LOCKSFX = 13;
        const CMD_BREAKSFX = 14;
        const CMD_PARTYSFX = 15;
        const CMD_JOKESFX = 16;
        const CMD_CRASHSFX = 17;
        const CMD_ICRASHSFX = 18;
        const CMD_RIPSFX = 19;
        const CMD_WHOOSHSFX = 20;
        const CMD_FALLSFX = 21;
        const CMD_MAGICSFX = 22;
        const CMD_BADMAGSFX = 23;
        const CMD_SQUEAKSFX = 24;

        // Voice Commands
        const CMD_TRIXIEOBJ = 26;
        const CMD_PHOENIXOBJ = 27;
        const CMD_TWIOBJ = 28;
        const CMD_FLUTTEROBJ = 29;
        const CMD_JUDGEOBJ = 30;
        const CMD_GROUPOBJ = 31;
        const CMD_TRIXIEHOLD = 32;
        const CMD_PHOENIXHOLD = 33;
        const CMD_PHOENIXTAKE = 34;
        const CMD_VOICEENDLIST = 35;

        // Music Commands
        const CMD_MUSSTEEL = 50;
        const CMD_MUSSTART = 51;
        const CMD_MUSEXAM = 52;
        const CMD_MUSCROSS = 53;
        const CMD_MUSTRICK = 54;
        const CMD_MUSMLP = 55;
        const CMD_MUSTROUPE = 56;
        const CMD_MUSTRIAL = 57;
        const CMD_MUSTRANCE = 58;
        const CMD_MUSPEARLY = 59;
        const CMD_MUSSISTER = 60;
        const CMD_MUSSMILE = 61;
        const CMD_MUSLOCK = 62;
        const CMD_MUSTRIALS = 63;
        const CMD_MUSPROLOG = 64;
        const CMD_MUSECHESS = 65;
        const CMD_MUSOBJECT = 66;
        const CMD_MUSTHRILL = 67;
        const CMD_MUSINTEREST = 68;
        const CMD_MUSTRAGIC = 69;
        const CMD_MUSMIDDLE = 70;
        const CMD_MUSKG8 = 71;
        const CMD_MUSLYING = 72;
        const CMD_MUSMOON = 73;
        const CMD_MUSWINTER = 74;
        const CMD_MUSLOUNGE = 75;
        const CMD_MUSHOTLINE = 76;
        const CMD_MUSSUSPENSE = 77;
        const CMD_MUSBEGIN = 78;
        const CMD_MUSTRUTH = 79;
        const CMD_MUSPURSUIT = 80;
        const CMD_MUSEND = 81;
        const CMD_MUSCORNERED = 82;
        const CMD_MUSSWEPT = 83;
        const CMD_MUSCORE = 84;
        const CMD_MUSPRELUDE = 85;
        const CMD_MUSGIGGLE = 86;
        const CMD_MUSCOURT = 87;
        const CMD_MUSWON = 88;
        const CMD_MUSAJ = 89;
        const CMD_MUSRARITY = 90;
        const CMD_MUSTRUCY = 91;
        const CMD_MUSELEGY = 92;
        const CMD_MUSGUILTY = 93;
        const CMD_MUSRECALL = 94;
        const CMD_MUSCRUSADE = 95;
        const CMD_MUSCLOCK = 96;
        const CMD_MUSSPECIAL = 97;
        const CMD_MUSCOOL = 98;
        const CMD_MUSMEMORY = 99;
        const CMD_MUSSCHESS = 100;
        const CMD_MUSOBJECT2 = 101;
        const CMD_MUSOBJECT3 = 102;
        const CMD_MUSFALL = 103;

        // Action Commands
        const CMD_JUMP = 200;
        const CMD_SHOWEV = 201;
        const CMD_JUMPIFSHOW = 202;
        const CMD_INVESTIGATE = 203;
        const CMD_REMOVEEV = 204;
        const CMD_ADDEV = 205;
        const CMD_JUMPIFEV = 206;
        const CMD_JUMPIFNOEV = 207;
        const CMD_CLRPROMPT = 208;
        const CMD_ADDPROMPT = 209;
        const CMD_CHANGEPROMPT = 210;
        const CMD_SELPROMPT = 211;
        const CMD_ENDSTORY = 212;
        const CMD_ADDTEST = 213;
        const CMD_OBJECTHERE = 214;
        const CMD_BADOBJECT = 215;
        const CMD_GOODOBJECT = 216;
        const CMD_STARTTEST = 217;
        const CMD_STARTCROSS = 218;
        const CMD_CONCROSS = 219;
        const CMD_RESETMISS = 220;

        // Miss system constants
        const DEFAULT_MISSES = 4;
    </script>

    <!-- Load story data after constants are defined -->
    <script src="storydata.js"></script>

    <script>
        // Phoenix Wright HTML5 Game Engine
        class PhoenixWrightGame {
            constructor() {
                this.evidence_found = new Array(EV_MAX_STORED_EV).fill(0);
                this.people_found = new Array(PP_MAX).fill(0);
                this.currentImage = -1;
                this.currentText = "";
                this.currentName = -1;
                this.maxText = 32 * 7; // Default text limit
                this.sprites = "";
                this.storyIndex = 0;
                this.lastValidStoryIndex = 0;   // remember last CMD_NONE for saving
                this.missesLeft = 0;
                this.recallMisses = 0;      // Stored miss count for recall
                this.missesTarget = 0;      // Target tag for game over
                this.investigationMode = false;
                this.investigationCells = [];
                this.prompts = [];
                this.currentLocation = 0;
                this.typewriterActive = false;
                this.typewriterText = "";
                this.typewriterIndex = 0;
                this.typewriterInterval = null;
                this.currentMusic = null;
                this.musicAudio = null;
                this.awaitingEvidenceSelection = false;
                this.selectedEvidenceId = null;
                this.presentedEvidenceId = null;

                // Testimony/Cross-examination system
                this.testimonyArray = [];      // up to 16 testimonies - indices into story
                this.maxTestimony = 0;         // number of testimonies loaded
                this.currentTestimony = 0;     // testimony we are looking at
                this.testimonyMode = 0;        // 0 = normal story, 1 = giving testimony, 2 = cross examination
                this.badObjectTarget = 0;      // tag for bad objection
                this.goodObjectTarget = 0;     // tag for good objection
                this.postTestTarget = 0;       // tag to continue after testimony/cross-examination

                // UI Elements
                this.imageEl = document.getElementById('gameImage');
                this.textEl = document.getElementById('textDisplay');
                this.nameEl = document.getElementById('nameDisplay');
                this.spritesEl = document.getElementById('sprites');
                this.cursorEl = document.getElementById('investigationCursor');
                this.missesEl = document.getElementById('missesDisplay');
                this.loadingEl = document.getElementById('loadingScreen');
                this.mainMenuEl = document.getElementById('mainMenu');
                this.cheatMenuEl = document.getElementById('cheatMenu');
                this.evidenceMenuEl = document.getElementById('evidenceMenu');
                this.evidenceDetailEl = document.getElementById('evidenceDetail');
                this.conversationMenuEl = document.getElementById('conversationMenu');
                this.fileMenuEl = document.getElementById('fileMenu');
                this.buttonBarEl = document.getElementById('buttonBar');

                // Button elements
                this.nextBtnEl = document.getElementById('nextBtn');
                this.evidenceBtnEl = document.getElementById('evidenceBtn');
                this.pressBtnEl = document.getElementById('pressBtn');
                this.objectionBtnEl = document.getElementById('objectionBtn');
                this.leftBtnEl = document.getElementById('leftBtn');
                this.rightBtnEl = document.getElementById('rightBtn');
                this.fileBtnEl = document.getElementById('fileBtn');

                this.init();
            }

            init() {
                // Initialize with starting evidence
                this.addInventory(EV_BADGE);
                this.addInventory(EV_MAGATAMA);
                this.addInventory(PP_PHOENIX);

                // Set up event listeners for investigation mode and escape key
                document.addEventListener('click', (e) => this.handleClick(e));
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));

                // Show main menu
                this.showMainMenu();
            }

            showMainMenu() {
                // Check if we're currently in a game (button bar is visible = game active)
                if (this.buttonBarEl.style.display === 'flex') {
                    // Show confirmation dialog
                    const confirmed = confirm("Returning to the main menu will end your current game. Any unsaved progress will be lost.\n\nAre you sure you want to continue?");
                    if (!confirmed) {
                        return; // User cancelled, don't show main menu
                    }
                }

                this.hideLoading();
                this.hideButtonBar();
                this.stopMusic();
                this.hideAllMenus(); // Close any open menus (including file menu)
                this.mainMenuEl.style.display = 'block';
            }

            showButtonBar() {
                this.buttonBarEl.style.display = 'flex';
            }

            hideButtonBar() {
                this.buttonBarEl.style.display = 'none';
            }

            hideAllMenus() {
                this.mainMenuEl.style.display = 'none';
                this.cheatMenuEl.style.display = 'none';
                this.evidenceMenuEl.style.display = 'none';
                this.evidenceDetailEl.style.display = 'none';
                this.conversationMenuEl.style.display = 'none';
                this.fileMenuEl.style.display = 'none';
                this.updateButtonStates('story'); // Refresh button states with menus closed
                this.focusNextButton(); // Return focus to Next button
            }

            hideLoading() {
                this.loadingEl.style.display = 'none';
            }

            startNew() {
                this.hideAllMenus();
                this.showButtonBar();
                this.updateButtonStates('story');
                this.loadLocation(0); // Start at location 0
            }

            showFileMenu() {
                this.fileMenuEl.style.display = 'block';
                this.updateButtonStates('story'); // Refresh button states with menu active

                // Focus the first menu item
                const firstMenuItem = this.fileMenuEl.querySelector('.menu-item[tabindex="0"]');
                if (firstMenuItem) {
                    setTimeout(() => firstMenuItem.focus(), 50); // Small delay to ensure menu is visible
                }
            }

            closeFileMenu() {
                this.fileMenuEl.style.display = 'none';
                this.updateButtonStates('story'); // Refresh button states with menu closed
                this.focusNextButton(); // Return focus to Next button
            }

            saveGame() {
                const saveData = {
                    evidence_found: this.evidence_found,
                    people_found: this.people_found,
                    currentLocation: this.currentLocation,
                    storyIndex: this.lastValidStoryIndex,
                    missesLeft: this.missesLeft,
                    recallMisses: this.recallMisses,
                    missesTarget: this.missesTarget,
                    timestamp: new Date().toISOString()
                };

                localStorage.setItem('phoenixWrightSave', JSON.stringify(saveData));
                alert("Game saved successfully!");
            }

            loadGame() {
                const saveData = localStorage.getItem('phoenixWrightSave');
                if (!saveData) {
                    alert("No save file found!");
                    return;
                }

                try {
                    const data = JSON.parse(saveData);
                    this.evidence_found = data.evidence_found || new Array(EV_MAX_STORED_EV).fill(0);
                    this.people_found = data.people_found || new Array(PP_MAX).fill(0);

                    // Restore miss system state
                    this.missesLeft = data.missesLeft || 0;
                    this.recallMisses = data.recallMisses || 0;
                    this.missesTarget = data.missesTarget || 0;

                    this.hideAllMenus();
                    this.showButtonBar();
                    this.updateButtonStates('story');
                    this.loadLocation(data.currentLocation || 0, data.storyIndex || 0);

                    alert(`Game loaded from ${new Date(data.timestamp).toLocaleString()}`);
                } catch (e) {
                    alert("Save file corrupted!");
                }
            }

            showCredits() {
                alert("Phoenix Wright / My Little Pony - Turnabout Storm\n\nOriginal video by PWaaMLPfim\nTitle image by HowXu\n\nBased on TI port by Tursilion");
            }

            showCheatMenu() {
                // Populate cheat menu with available locations
                const cheatLocationList = document.getElementById('cheatLocationList');
                cheatLocationList.innerHTML = '';

                let firstItem = null;

                // Get all available locations from STORY_DATA
                for (const locationNum in STORY_DATA) {
                    if (STORY_DATA.hasOwnProperty(locationNum)) {
                        const item = document.createElement('div');
                        item.className = 'menu-item';
                        item.textContent = `Location ${locationNum}`;
                        item.tabIndex = 0;
                        item.onclick = () => this.cheatJumpToLocation(parseInt(locationNum));
                        cheatLocationList.appendChild(item);
                        if (!firstItem) firstItem = item;
                    }
                }

                this.cheatMenuEl.style.display = 'block';

                // Focus the first item
                if (firstItem) {
                    setTimeout(() => firstItem.focus(), 50);
                }
            }

            closeCheatMenu() {
                this.cheatMenuEl.style.display = 'none';
                this.mainMenuEl.style.display = 'block'; // Return to main menu
            }

            cheatJumpToLocation(locationNum) {
                console.log(`Cheat: Jumping to location ${locationNum}`);

                // Mark all evidence as found (cheat mode)
                this.evidence_found.fill(1);
                this.people_found.fill(1);

                // Hide menus and show game
                this.hideAllMenus();
                this.showButtonBar();
                this.updateButtonStates('story');

                // Load the selected location at index 0
                this.loadLocation(locationNum, 0);
            }

            loadImage(imageIndex) {
                if (imageIndex === this.currentImage) return;

                this.currentImage = imageIndex;

                // Convert image index to PNG filename
                const paddedIndex = imageIndex.toString().padStart(4, '0');
                const imageUrl = `png/${paddedIndex}.png`;

                console.log(`Loading image: ${imageUrl}`); // Debug logging

                // Clear previous handlers
                this.imageEl.onload = null;
                this.imageEl.onerror = null;

                // Set up new handlers
                this.imageEl.onload = () => {
                    console.log(`Successfully loaded: ${imageUrl}`);
                    this.imageEl.style.display = 'block';
                };

                this.imageEl.onerror = () => {
                    console.warn(`Failed to load image: ${imageUrl}`);
                    // Don't hide the element, just show a placeholder
                    this.imageEl.style.display = 'block';
                    this.imageEl.alt = `Missing: ${imageUrl}`;
                };

                // Set the source to trigger loading
                this.imageEl.src = imageUrl;
            }

            clearText() {
                this.textEl.textContent = "";
            }

            setText(text) {
                this.currentText = text;
                this.startTypewriter(text);
            }

            startTypewriter(text) {
                if (this.typewriterInterval) {
                    clearInterval(this.typewriterInterval);
                }

                this.typewriterActive = true;
                this.typewriterText = text;
                this.typewriterIndex = 0;
                this.textEl.textContent = "";

                if (!text || text.length === 0) {
                    this.typewriterActive = false;
                    return;
                }

                // 100 characters per second = 10ms per character
                this.typewriterInterval = setInterval(() => {
                    if (this.typewriterIndex < this.typewriterText.length) {
                        this.textEl.textContent = this.typewriterText.substring(0, this.typewriterIndex + 1);
                        this.typewriterIndex++;
                    } else {
                        clearInterval(this.typewriterInterval);
                        this.typewriterInterval = null;
                        this.typewriterActive = false;
                    }
                }, 10);
            }

            skipTypewriter() {
                if (this.typewriterActive && this.typewriterInterval) {
                    clearInterval(this.typewriterInterval);
                    this.typewriterInterval = null;
                    this.typewriterActive = false;
                    this.textEl.textContent = this.typewriterText;
                }
            }

            setName(nameId) {
                this.currentName = nameId;
                this.updateDisplay();
            }

            updateDisplay() {
                // Update name display
                if (this.currentName >= 0) {
                    const name = this.getPersonName(this.currentName);
                    // Add miss count to the right side of the name if misses are active
                    if (this.missesLeft > 0) {
                        this.nameEl.innerHTML = `${name}<span style="float: right;">Misses: ${this.missesLeft}</span>`;
                    } else {
                        this.nameEl.textContent = name;
                    }
                    this.nameEl.style.display = 'block';
                } else {
                    this.nameEl.style.display = 'none';
                }

                // Update text with word wrap (simplified)
                if (this.currentText) {
                    let displayText = this.currentText;
                    if (displayText.length > this.maxText) {
                        displayText = displayText.substring(0, this.maxText);
                    }
                    this.textEl.textContent = displayText;
                }

                // Update sprites
                this.spritesEl.textContent = this.sprites;

                // Update misses
                if (this.missesLeft > 0) {
                    document.getElementById('missesCount').textContent = this.missesLeft;
                    this.missesEl.style.display = 'block';
                } else {
                    this.missesEl.style.display = 'none';
                }
            }

            getPersonName(personId) {
                const names = {
                    [PP_PHOENIX]: "Phoenix Wright",
                    [PP_TWILIGHT]: "Twilight Sparkle",
                    [PP_UNKNOWN]: "???",
                    [PP_GUARD]: "Guard",
                    [PP_RAINBOW]: "Rainbow Dash",
                    [PP_ACE2]: "Ace Swift",
                    [PP_ACE]: "Ace Swift",
                    [PP_FLUTTERSHY]: "Fluttershy",
                    [PP_TRIXIE]: "Trixie",
                    [PP_JUDGE]: "Judge",
                    [PP_BLOOM]: "Apple Bloom",
                    [PP_PINKIE]: "Pinkie Pie",
                    [PP_SONATA]: "Sonata",
                    [PP_EDGEWORTH]: "Miles Edgeworth",
                    [PP_TESTIMONY]: "Testimony",
                    [PP_CROSSEXAM]: "Cross-Examination",
                    [PP_GALLERY]: "Gallery"
                };
                return names[personId] || "Unknown";
            }

            addInventory(id) {
                if (id >= PP_FIRST) {
                    const index = ((id >> 8) - (PP_FIRST >> 8));
                    if (index < PP_MAX) {
                        this.people_found[index] = 1;
                    }
                } else if (id < EV_MAX_STORED_EV) {
                    this.evidence_found[id] = 1;
                }
            }

            removeInventory(id) {
                if (id >= PP_FIRST) {
                    const index = ((id >> 8) - (PP_FIRST >> 8));
                    if (index < PP_MAX) {
                        this.people_found[index] = 0;
                    }
                } else if (id < EV_MAX_STORED_EV) {
                    this.evidence_found[id] = 0;
                }
            }

            hasInventory(id) {
                if (id >= PP_FIRST) {
                    const index = ((id >> 8) - (PP_FIRST >> 8));
                    return index < PP_MAX ? this.people_found[index] !== 0 : false;
                } else if (id < EV_MAX_STORED_EV) {
                    return this.evidence_found[id] !== 0;
                }
                return false;
            }

            loadLocation(locationNumber, startingStoryIndex = 0) {
                this.currentLocation = locationNumber;
                this.storyIndex = startingStoryIndex;
                this.lastValidStoryIndex = 0;

                // Clear testimony system when changing location
                this.testimonyArray = [];
                this.maxTestimony = 0;
                this.currentTestimony = 0;
                this.testimonyMode = 0;
                this.badObjectTarget = 0;
                this.goodObjectTarget = 0;
                this.postTestTarget = 0;

                // Clear miss system when changing location
                this.missesLeft = 0;
                this.recallMisses = 0;
                this.missesTarget = 0;

                // Load story data from external file
                this.currentStoryData = STORY_DATA[locationNumber] || [];

                if (this.currentStoryData.length > 0) {
                    this.processStoryLine(this.currentStoryData[this.storyIndex]);
                } else {
                    this.loadImage(locationNumber + 1000);
                    this.setText(`Location ${locationNumber} - No story data available yet.`);
                    this.setName(PP_PHOENIX);
                }
            }

            showEvidence() {
                // Show evidence selection menu
                const evidenceList = document.getElementById('evidenceList');
                evidenceList.innerHTML = '';

                let firstItem = null;

                // Add evidence items
                for (let i = 0; i < EV_START_INTERNAL; i++) {
                    if (this.evidence_found[i]) {
                        const item = document.createElement('div');
                        item.className = 'menu-item';
                        item.textContent = this.getEvidenceName(i);
                        item.tabIndex = 0; // Make focusable
                        item.onclick = () => this.selectEvidence(i);
                        evidenceList.appendChild(item);
                        if (!firstItem) firstItem = item;
                    }
                }

                // Add people
                for (let i = 0; i < PP_MAX; i++) {
                    if (this.people_found[i]) {
                        const personId = PP_FIRST + (i << 8);
                        const item = document.createElement('div');
                        item.className = 'menu-item';
                        item.textContent = this.getPersonName(personId);
                        item.tabIndex = 0; // Make focusable
                        item.onclick = () => this.selectEvidence(personId);
                        evidenceList.appendChild(item);
                        if (!firstItem) firstItem = item;
                    }
                }

                this.evidenceMenuEl.style.display = 'block';
                this.updateButtonStates('story'); // Refresh button states with menu active

                // Hide close button if presenting evidence, show if just viewing
                const closeButton = document.getElementById('evidenceCloseButton');
                if (this.awaitingEvidenceSelection) {
                    closeButton.style.display = 'none';
                } else {
                    closeButton.style.display = 'block';
                }

                // Focus the first item
                if (firstItem) {
                    setTimeout(() => firstItem.focus(), 50); // Small delay to ensure menu is visible
                }
            }

            showEvidenceForPresentation() {
                // Same as showEvidence() but specifically for CMD_JUMPIFSHOW
                this.awaitingEvidenceSelection = true;
                this.showEvidence();
            }

            getEvidenceName(evidenceId) {
                const names = {
                    [EV_BADGE]: "Attorney's Badge",
                    [EV_MAGATAMA]: "Magatama",
                    [EV_FILLIES]: "Fillies Guide",
                    [EV_E_BADGE]: "Equestrian Attorney Badge",
                    [EV_EQ500]: "Equestria 500 Information",
                    [EV_EVERFREE]: "Everfree Forest Map",
                    [EV_PHOTO1]: "Crime Scene Photo 1",
                    [EV_BURNT]: "Burnt Metal Object",
                    [EV_PHOTO2]: "Crime Scene Photo 2",
                    [EV_FEATHER]: "Suspicious Feather",
                    [EV_AUTOPSY]: "Autopsy Report",
                    [EV_CRIMESCENE]: "Crime Scene Diagram",
                    [EV_WEATHER]: "Weather Schedule",
                    [EV_CLOUDREPORT]: "Cloud Report",
                    [EV_PICTURES]: "Rainbow Dash Photos",
                    [EV_BLACKMAIL]: "Blackmail Letter",
                    [EV_ACEKEY]: "Hotel Key",
                    [EV_TORNRESIGN]: "Torn Resignation",
                    [EV_UNICORNSPELL]: "Unicorn Spell Book",
                    [EV_LIST]: "List of Names"
                };
                return names[evidenceId] || `Evidence ${evidenceId}`;
            }

            getEvidenceDescription(evidenceId) {
                const descriptions = {
                    [EV_BADGE]: "Nobody would believe I was an attorney without this.",
                    [EV_MAGATAMA]: "A gift from Maya. Allows me to see if anyone is hiding any deep secret in their heart from me.",
                    [EV_FILLIES]: "Earth Ponies founded Land, Unicorns use magic, Pegasi soar through the air.",
                    [EV_E_BADGE]: "A heart shaped badge that gives all the privileges of an Equestrian defense Attorney",
                    [EV_EQ500]: "A gruelling 500 mile race around Equestria for pegasi. Ace Swift was expected to win.",
                    [EV_EVERFREE]: "Location of the crime. Incredibly dark and secluded, especially at night.",
                    [EV_PHOTO1]: "Shows charred and blackened grass around body.",
                    [EV_BURNT]: "A metal object that was severely burned by something. It is unidentifiable now.",
                    [EV_PHOTO2]: "An imprint of what seems to be something long. Next to it some markings indicating someone had scuffled the dirt around.",
                    [EV_FEATHER]: "A suspicious brown feather that doesn't belong to a bird or a pony.",
                    [EV_AUTOPSY]: "Estimated time of death: 8:30pm - 9:00pm. Died instantly due to severe electrocution. Burn mark on the back of the neck: unknown cause.",
                    [EV_CRIMESCENE]: "Bolt 1 struck at 8:40PM where victim was found. Bolt 2 unknown but struck at 8:50. Bolt 3 took down a tree near the eastern edge of the clearing at 11:35PM.",
                    [EV_WEATHER]: "Rainbow Dash scheduled to create a thunder storm at 3pm on the eastern side of Ponyville. Everfree Forest is on the west side of town.",
                    [EV_CLOUDREPORT]: "A cloud Rainbow Dash was in charge of disappeared at 4:00PM on the night of the murder, and was found above the Everfree Forest Clearing.",
                    [EV_PICTURES]: "Several pictures of Rainbow Dash... Why in her right mind would she be doing this...? Photos found in a bag on the victim.",
                    [EV_BLACKMAIL]: "A letter blackmailing Rainbow Dash that she found on her doorstep.",
                    [EV_ACEKEY]: "A key to the hotel Ace Swift was staying in while in Ponyville.",
                    [EV_TORNRESIGN]: "Someone was planning on quitting something after the Equestrian 500. The other half is missing.",
                    [EV_UNICORNSPELL]: "A book found in the victim's hotel room. Small note scribbled on one of the pages.",
                    [EV_LIST]: "A list with several names including Rainbow Dash."
                };
                return descriptions[evidenceId] || `No description available for evidence ${evidenceId}.`;
            }

            getPersonDescription(evidenceId) {
                const descriptions = {
                    [PP_PHOENIX]: "That's me, attorney at law!",
                    [PP_TWILIGHT]: "Unicorn disciple of Princess Celestia. Summoned the 'Greatest Defense Attorney' to Equestria.",
                    [PP_GUARD]:  "Royal Equestrian Guard, they appear to handle most police duties here.",
                    [PP_RAINBOW]:	"The Defendent: Pegasus racer, the 'best flier in Equestria'. Accused of the murder of Ace Swift.",
                    [PP_ACE2]:	"The victim, a professional pegasus racer. Found dead in the Everfree Forest.",
                    [PP_ACE]:	"The victim, a professional pegasus racer. Never lost an event. Found dead in the Everfree Forest.",
                    [PP_FLUTTERSHY]:	"Pegasus friend of Rainbow Dash. Animal caretaker. Witness who lives near the Everfree Forest.",
                    [PP_TRIXIE]:	"The Great and Powerful Trixie, unicorn magician and prosecutor. Has a grudge against Twilight.",
                    [PP_JUDGE]: "The Judge also seems to have been called! He's fair, though easily confused.",
                    [PP_BLOOM]:	"Earth pony child, Cutie Mark Crusader. Witness who was in the Everfree Forest the night of the crime.",
                    [PP_PINKIE]:	"Earth pony Party Thrower Extraordinaire. Friend of Rainbow Dash.",
                    [PP_SONATA]:	"Unicorn manager of Ace Swift. Resembles Mia from my own realm."
                };
                return descriptions[evidenceId] || `No description available for person ${evidenceId}.`;
            }

            selectEvidence(evidenceId) {
                // Show evidence detail view
                this.showEvidenceDetail(evidenceId);
            }

            showEvidenceDetail(evidenceId) {
                this.evidenceMenuEl.style.display = 'none';
                this.selectedEvidenceId = evidenceId;

                const nameEl = document.getElementById('evidenceDetailName');
                const descEl = document.getElementById('evidenceDetailDescription');
                const presentBtn = document.getElementById('presentEvidenceBtn');

                if (evidenceId >= PP_FIRST) {
                    // Person evidence
                    nameEl.textContent = this.getPersonName(evidenceId);
                    descEl.innerHTML = `<p>${this.getPersonDescription(evidenceId)}</p>`;
                } else {
                    // Regular evidence
                    nameEl.textContent = this.getEvidenceName(evidenceId);
                    descEl.innerHTML = `<p>${this.getEvidenceDescription(evidenceId)}</p>`;
                }

                // Show present button only if awaiting evidence selection
                if (this.awaitingEvidenceSelection) {
                    presentBtn.style.display = 'block';
                } else {
                    presentBtn.style.display = 'none';
                }

                this.evidenceDetailEl.style.display = 'block';
                this.updateButtonStates('story'); // Refresh button states with menu active
            }

            presentEvidence() {
                if (this.awaitingEvidenceSelection && this.selectedEvidenceId !== null) {
                    this.awaitingEvidenceSelection = false;
                    this.presentedEvidenceId = this.selectedEvidenceId;
                    this.hideAllMenus();

                    console.log("Presented evidence:", this.selectedEvidenceId);

                    // Continue story after evidence selection
                    this.advanceStory();
                }
            }

            closeEvidence() {
                this.evidenceMenuEl.style.display = 'none';
                this.evidenceDetailEl.style.display = 'none';
                this.updateButtonStates('story'); // Refresh button states with menu closed
                this.focusNextButton(); // Return focus to Next button
            }

            closeEvidenceDetail() {
                this.evidenceDetailEl.style.display = 'none';
                this.evidenceMenuEl.style.display = 'block';
                this.updateButtonStates('story'); // Refresh button states with menu active
            }

            startInvestigation(sceneNumber) {
                this.investigationMode = true;
                this.investigationFlags = sceneNumber; // Store the bitflags from frame
                this.cursorEl.style.display = 'block';
                this.setText("Click area to inspect");
                this.updateButtonStates('investigation');

                // Set up investigation cells (8 clickable areas)
                this.investigationCells = [];
                for (let i = 0; i < 8; i++) {
                    this.investigationCells.push({
                        x: (i % 4) * 25, // 4 across
                        y: Math.floor(i / 4) * 50, // 2 down
                        width: 25,
                        height: 50,
                        evidence: 0 // EV_I_0 + i
                    });
                }
            }


            handleClick(e) {
                if (this.investigationMode) {
                    const rect = this.imageEl.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;

                    // Check which investigation cell was clicked
                    for (let i = 0; i < this.investigationCells.length; i++) {
                        const cell = this.investigationCells[i];
                        if (x >= cell.x && x < cell.x + cell.width &&
                            y >= cell.y && y < cell.y + cell.height) {
                            this.investigateCell(i);
                            break;
                        }
                    }
                }
            }

            investigateCell(cellIndex) {
                this.investigationMode = false;
                this.presentedEvidenceId = cellIndex + EV_I_0;
                this.cursorEl.style.display = 'none';
                this.updateButtonStates('story'); // Return to story mode

                // Continue story progression after investigation
                this.advanceStory();
            }

            handleKeyDown(e) {
                // Handle '?' key to show cheat menu (only when main menu is active)
                if (e.key === '?' && this.mainMenuEl.style.display === 'block') {
                    this.showCheatMenu();
                    return;
                }

                // Handle Escape key to close menus
                if (e.key === 'Escape') {
                    // Check which menus are open and close them
                    if (this.evidenceMenuEl.style.display === 'block' ||
                        this.evidenceDetailEl.style.display === 'block') {
                        this.closeEvidence();
                    } else if (this.conversationMenuEl.style.display === 'block') {
                        this.conversationMenuEl.style.display = 'none';
                        this.updateButtonStates('story'); // Refresh button states with menu closed
                        this.focusNextButton(); // Return focus to Next button
                    } else if (this.fileMenuEl.style.display === 'block') {
                        this.closeFileMenu();
                    } else if (this.cheatMenuEl.style.display === 'block') {
                        this.closeCheatMenu();
                    }
                    return;
                }

                // Handle arrow key navigation within menus
                if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    const focusedElement = document.activeElement;
                    if (focusedElement && focusedElement.classList.contains('menu-item')) {
                        e.preventDefault(); // Prevent page scrolling

                        // Find all focusable menu items in the same menu
                        const menu = focusedElement.closest('.menu');
                        if (menu) {
                            const menuItems = Array.from(menu.querySelectorAll('.menu-item[tabindex="0"]'));
                            const currentIndex = menuItems.indexOf(focusedElement);

                            if (currentIndex !== -1) {
                                let nextIndex;
                                if (e.key === 'ArrowDown') {
                                    nextIndex = (currentIndex + 1) % menuItems.length; // Wrap to beginning
                                } else {
                                    nextIndex = (currentIndex - 1 + menuItems.length) % menuItems.length; // Wrap to end
                                }
                                menuItems[nextIndex].focus();
                            }
                        }
                    }
                    return;
                }

                // Handle Enter key to activate focused menu item
                if (e.key === 'Enter') {
                    const focusedElement = document.activeElement;
                    if (focusedElement && focusedElement.classList.contains('menu-item')) {
                        e.preventDefault();
                        focusedElement.click(); // Trigger the onclick event
                    }
                }
            }

            // Button handlers
            nextButton() {
                if (!this.isButtonDisabled('next')) {
                    this.advanceStory();
                }
            }

            evidenceButton() {
                if (!this.isButtonDisabled('evidence')) {
                    this.showEvidence();
                }
            }

            pressButton() {
                if (!this.isButtonDisabled('press')) {
                    // Press for more information - only available in cross-examination mode
                    if (this.testimonyMode === 2) {
                        console.log("Press button clicked - ending cross-examination mode");
                        this.testimonyMode = 0;
                        // Jump to the evidence tag of the current testimony line (press target)
                        const currentStoryLine = this.currentStoryData[this.storyIndex];
                        this.jumpToTag(currentStoryLine.evidence);
                    } else {
                        console.log("Press button clicked outside cross-examination mode");
                    }
                }
            }

            objectionButton() {
                if (!this.isButtonDisabled('objection')) {
                    // Object! Check if this is the correct place to object
                    if (this.testimonyMode === 2) {
                        console.log("Objection button clicked");
                        const currentStoryLine = this.currentStoryData[this.storyIndex];
                        const cmd = currentStoryLine.cmdwho & 0xff;

                        this.testimonyMode = 0; // End cross-examination mode

                        if (cmd === CMD_OBJECTHERE) {
                            // Good objection! Stop music and jump to good object target
                            console.log("Good objection! Jumping to good target");
                            this.stopMusic();
                            this.jumpToTag(this.goodObjectTarget);
                        } else {
                            // Bad objection - jump to bad object target
                            console.log("Bad objection! Jumping to bad target");
                            this.jumpToTag(this.badObjectTarget);
                        }
                    } else {
                        console.log("Objection button clicked outside cross-examination mode");
                    }
                }
            }

            fileButton() {
                if (!this.isButtonDisabled('file')) {
                    this.showFileMenu();
                }
            }

            leftButton() {
                if (!this.isButtonDisabled('left')) {
                    // Exit investigation mode and set evidence ID for "move left"
                    this.investigationMode = false;
                    this.presentedEvidenceId = EV_I_SEARCH_LEFT;
                    this.cursorEl.style.display = 'none';
                    this.updateButtonStates('story');
                    this.advanceStory();
                }
            }

            rightButton() {
                if (!this.isButtonDisabled('right')) {
                    // Exit investigation mode and set evidence ID for "move right"
                    this.investigationMode = false;
                    this.presentedEvidenceId = EV_I_SEARCH_RIGHT;
                    this.cursorEl.style.display = 'none';
                    this.updateButtonStates('story');
                    this.advanceStory();
                }
            }

            // Button state management
            enableButton(buttonName) {
                const buttonEl = this.getButtonElement(buttonName);
                if (buttonEl) {
                    buttonEl.classList.remove('disabled');
                }
            }

            disableButton(buttonName) {
                const buttonEl = this.getButtonElement(buttonName);
                if (buttonEl) {
                    buttonEl.classList.add('disabled');
                }
            }

            enableAllButtons() {
                this.enableButton('next');
                this.enableButton('evidence');
                this.enableButton('press');
                this.enableButton('objection');
                this.enableButton('left');
                this.enableButton('right');
                this.enableButton('file');
            }

            disableAllButtons() {
                this.disableButton('next');
                this.disableButton('evidence');
                this.disableButton('press');
                this.disableButton('objection');
                this.disableButton('left');
                this.disableButton('right');
                this.disableButton('file');
            }

            isButtonDisabled(buttonName) {
                const buttonEl = this.getButtonElement(buttonName);
                return buttonEl ? buttonEl.classList.contains('disabled') : true;
            }

            getButtonElement(buttonName) {
                switch(buttonName) {
                    case 'next': return this.nextBtnEl;
                    case 'evidence': return this.evidenceBtnEl;
                    case 'press': return this.pressBtnEl;
                    case 'objection': return this.objectionBtnEl;
                    case 'left': return this.leftBtnEl;
                    case 'right': return this.rightBtnEl;
                    case 'file': return this.fileBtnEl;
                    default: return null;
                }
            }

            // Check if any popup menu is currently active
            isAnyMenuActive() {
                return this.evidenceMenuEl.style.display === 'block' ||
                       this.evidenceDetailEl.style.display === 'block' ||
                       this.conversationMenuEl.style.display === 'block' ||
                       this.fileMenuEl.style.display === 'block' ||
                       this.mainMenuEl.style.display === 'block' ||
                       this.cheatMenuEl.style.display === 'block';
            }

            // Helper method to return focus to the Next button after closing menus
            focusNextButton() {
                if (this.nextBtnEl && !this.isButtonDisabled('next')) {
                    setTimeout(() => this.nextBtnEl.focus(), 50);
                }
            }

            // Context-sensitive button state management
            updateButtonStates(context) {
                // Always disable next button if any menu is active
                const menuActive = this.isAnyMenuActive();

                switch(context) {
                    case 'story':
                        // Normal story mode - Next and Evidence available (unless menu is active)
                        if (menuActive) {
                            this.disableButton('next');
                        } else {
                            this.enableButton('next');
                        }
                        this.enableButton('evidence');
                        this.disableButton('press');
                        this.disableButton('objection');
                        this.disableButton('left');
                        this.disableButton('right');
                        this.enableButton('file');
                        break;
                    case 'investigation':
                        // Investigation mode - Evidence available, Next disabled, Left/Right based on bitflags
                        this.disableButton('next');
                        this.enableButton('evidence');
                        this.disableButton('press');
                        this.disableButton('objection');

                        // Enable left/right buttons based on bitflags
                        if (this.investigationFlags & IV_LEFTOK) {
                            this.enableButton('left');
                        } else {
                            this.disableButton('left');
                        }

                        if (this.investigationFlags & IV_RIGHTOK) {
                            this.enableButton('right');
                        } else {
                            this.disableButton('right');
                        }

                        this.enableButton('file');
                        break;
                    case 'testimony':
                        // Testimony mode - only Next and Evidence available (unless menu is active)
                        if (menuActive) {
                            this.disableButton('next');
                        } else {
                            this.enableButton('next');
                        }
                        this.enableButton('evidence');
                        this.disableButton('press');
                        this.disableButton('objection');
                        this.disableButton('left');
                        this.disableButton('right');
                        this.enableButton('file');
                        break;
                    case 'cross-examination':
                        // Cross-examination - Next, Press and Objection available (unless menu is active)
                        if (menuActive) {
                            this.disableButton('next');
                        } else {
                            this.enableButton('next');
                        }
                        this.enableButton('evidence');
                        this.enableButton('press');
                        this.enableButton('objection');
                        this.disableButton('left');
                        this.disableButton('right');
                        this.enableButton('file');
                        break;
                    case 'conversation':
                        // Conversation menu - only Evidence and File
                        this.disableButton('next');
                        this.enableButton('evidence');
                        this.disableButton('press');
                        this.disableButton('objection');
                        this.disableButton('left');
                        this.disableButton('right');
                        this.enableButton('file');
                        break;
                    case 'disabled':
                        // All buttons disabled
                        this.disableAllButtons();
                        break;
                    default:
                        // Default: enable basic buttons (unless menu is active)
                        if (menuActive) {
                            this.disableButton('next');
                        } else {
                            this.enableButton('next');
                        }
                        this.enableButton('evidence');
                        this.disableButton('press');
                        this.disableButton('objection');
                        this.disableButton('left');
                        this.disableButton('right');
                        this.enableButton('file');
                        break;
                }
            }

            processStoryLine(storyLine) {
                // Process story commands
                const cmd = storyLine.cmdwho & 0xff;
                const speaker = storyLine.cmdwho & 0xFF00;

                console.log(`Processing story line: cmd=${cmd}, speaker=${speaker.toString(16)} (${this.getPersonName(speaker)}), text="${storyLine.text}"`);

                // Commands that should execute silently and auto-advance (if they don't return)
                const silentCommands = [
                    CMD_ADDPROMPT, CMD_SELPROMPT, CMD_JUMP, CMD_JUMPIFSHOW,
                    CMD_CHANGEPROMPT, CMD_JUMPIFEV, CMD_JUMPIFNOEV, CMD_JUMPIFSHOW,
                    CMD_INVESTIGATE
                ];
                // silent only if text if empty
                const conditionalSilentCommands = [
                    CMD_ADDEV, CMD_REMOVEEV, CMD_CLRPROMPT,
                    CMD_BADOBJECT, CMD_GOODOBJECT, CMD_STOPMUS,
                    CMD_RESETMISS, CMD_CLEARMISS, CMD_STOREMISS, CMD_RECALLMISS
                ];

                // CMD_ADDTEST is silent only when not in testimony mode and has empty text
                const isAddTestSilent = ((cmd === CMD_ADDTEST || cmd === CMD_OBJECTHERE) && this.testimonyMode === 0);

                const isSilentCommand = silentCommands.includes(cmd) ||
                                      (conditionalSilentCommands.includes(cmd) && storyLine.text === "") ||
                                      isAddTestSilent;

                // Set speaker name (handle PP_NONE as no name) - but not for silent commands
                if (!isSilentCommand) {
                    // Override speaker name for testimony/cross-examination modes
                    if (this.testimonyMode === 1) {
                        this.setName(PP_TESTIMONY);
                    } else if (this.testimonyMode === 2) {
                        this.setName(PP_CROSSEXAM);
                    } else if (speaker > 0 && speaker !== PP_FIRST) { // PP_NONE/PP_FIRST is 0x8000
                        this.setName(speaker);
                    } else if (speaker === PP_FIRST) {
                        // Clear name for PP_NONE
                        this.currentName = -1;
                        this.updateDisplay();
                    }

                    // Handle CMD_BLACK - override image and show black screen
                    if (cmd === CMD_BLACK) {
                        this.blackScreen();
                    } else if (storyLine.frame >= 0) {
                        // Load image if specified (including frame 0) and not overridden by CMD_BLACK
                        this.loadImage(storyLine.frame);
                    }

                    this.setText(storyLine.text);
                }
                
                // Process special commands first
                switch (cmd) {
                    case CMD_NONE:
                    case CMD_BLACK:
                        // valid frame for save file
                        this.lastValidStoryIndex = this.storyIndex;
                        if (storyLine.text == "") {
                            setTimeout(() => this.advanceStory(), 10);
                        }
                        break;
                        
                    case CMD_ADDEV:
                        // Add evidence to inventory
                        if (storyLine.evidence > 0) {
                            this.addInventory(storyLine.evidence);
                        }
                        // Auto-advance for silent commands
                        setTimeout(() => this.advanceStory(), 10);
                        return;
                    case CMD_REMOVEEV:
                        // Remove evidence from inventory
                        if (storyLine.evidence > 0) {
                            this.removeInventory(storyLine.evidence);
                        }
                        // Auto-advance for silent commands
                        setTimeout(() => this.advanceStory(), 10);
                        return;
                    case CMD_FLASH:
                        this.flashScreen();
                        break;
                    case CMD_BLACK:
                        this.blackScreen();
                        break;
                    case CMD_WHITE:
                        this.whiteScreen();
                        break;
                    case CMD_STOPMUS:
                        this.playSound(CMD_CHIMESFX);
                        this.stopMusic();
                        break;
                    case CMD_SHOWEV:
                        this.showEvidenceForPresentation();
                        return;
                    case CMD_JUMPIFSHOW:
                        // Check if presented evidence matches expected evidence (stored in storyLine.evidence)
                        if (this.presentedEvidenceId === storyLine.evidence) {
                            // Evidence matches - jump to correct story line
                            this.jumpToTag(storyLine.frame);
                        } else {
                            // Evidence doesn't match or no evidence presented - continue normally
                            // (This allows multiple CMD_JUMPIFSHOW in sequence)
                        }
                        break;
                    case CMD_JUMPIFEV:
                        if (this.hasInventory(storyLine.evidence)) {
                            this.jumpToTag(storyLine.frame);
                            return;
                        }
                        break;
                    case CMD_JUMPIFNOEV:
                        if (!this.hasInventory(storyLine.evidence)) {
                            this.jumpToTag(storyLine.frame);
                            return;
                        }
                        break;
                    case CMD_INVESTIGATE:
                        this.startInvestigation(storyLine.frame);
                        return; // Wait for player to click a cell
                    case CMD_ENDSTORY:
                        this.stopMusic();
                        this.prompts = [];
                        this.loadLocation(storyLine.evidence);
                        return;
                    case CMD_JUMP:
                        this.jumpToTag(storyLine.evidence);
                        return;
                    case CMD_CLRPROMPT:
                        this.prompts = [];
                        // Auto-advance for silent commands
                        setTimeout(() => this.advanceStory(), 10);
                        return;
                    case CMD_ADDPROMPT:
                        this.addPrompt(storyLine.evidence, storyLine.text);
                        // Auto-advance to next line for ADDPROMPT commands
                        setTimeout(() => this.advanceStory(), 10);
                        return;
                    case CMD_SELPROMPT:
                        this.showConversationMenu();
                        return;
                    case CMD_CHANGEPROMPT:
                        this.changePrompt(storyLine.evidence, storyLine.text, storyLine.frame);
                        // Auto-advance to next line for CHANGEPROMPT commands
                        setTimeout(() => this.advanceStory(), 10);
                        return;
                    // Music commands
                    case CMD_MUSPROLOG:
                    case CMD_MUSSTEEL:
                    case CMD_MUSSTART:
                    case CMD_MUSEXAM:
                    case CMD_MUSCROSS:
                    case CMD_MUSTRICK:
                    case CMD_MUSMLP:
                    case CMD_MUSTROUPE:
                    case CMD_MUSTRIAL:
                    case CMD_MUSTRANCE:
                    case CMD_MUSPEARLY:
                    case CMD_MUSSISTER:
                    case CMD_MUSSMILE:
                    case CMD_MUSLOCK:
                    case CMD_MUSTRIALS:
                    case CMD_MUSECHESS:
                    case CMD_MUSOBJECT:
                    case CMD_MUSTHRILL:
                    case CMD_MUSINTEREST:
                    case CMD_MUSTRAGIC:
                    case CMD_MUSMIDDLE:
                    case CMD_MUSKG8:
                    case CMD_MUSLYING:
                    case CMD_MUSMOON:
                    case CMD_MUSWINTER:
                    case CMD_MUSLOUNGE:
                    case CMD_MUSHOTLINE:
                    case CMD_MUSSUSPENSE:
                    case CMD_MUSBEGIN:
                    case CMD_MUSTRUTH:
                    case CMD_MUSPURSUIT:
                    case CMD_MUSEND:
                    case CMD_MUSCORNERED:
                    case CMD_MUSSWEPT:
                    case CMD_MUSCORE:
                    case CMD_MUSPRELUDE:
                    case CMD_MUSGIGGLE:
                    case CMD_MUSCOURT:
                    case CMD_MUSWON:
                    case CMD_MUSAJ:
                    case CMD_MUSRARITY:
                    case CMD_MUSTRUCY:
                    case CMD_MUSELEGY:
                    case CMD_MUSGUILTY:
                    case CMD_MUSRECALL:
                    case CMD_MUSCRUSADE:
                    case CMD_MUSSCHESS:
                    case CMD_MUSOBJECT2:
                    case CMD_MUSOBJECT3:
                    case CMD_MUSFALL:
                        this.playMusic(cmd);
                        if (storyLine.text == "") {
                            setTimeout(() => this.advanceStory(), 10);
                        }
                        break;
                    // Sound effects
                    case CMD_HAMMERSFX:
                    case CMD_CHIMESFX:
                    case CMD_BOOMSFX:
                    case CMD_LOCKSFX:
                    case CMD_BREAKSFX:
                    case CMD_PARTYSFX:
                    case CMD_JOKESFX:
                    case CMD_CRASHSFX:
                    case CMD_ICRASHSFX:
                    case CMD_RIPSFX:
                    case CMD_WHOOSHSFX:
                    case CMD_FALLSFX:
                    case CMD_MAGICSFX:
                    case CMD_BADMAGSFX:
                    case CMD_SQUEAKSFX:
                        this.playSound(cmd);
                        if (storyLine.text == "") {
                            setTimeout(() => this.advanceStory(), 10);
                        }
                        break;
                    // Voice clips
                    case CMD_TRIXIEOBJ:
                    case CMD_PHOENIXOBJ:
                    case CMD_TWIOBJ:
                    case CMD_FLUTTEROBJ:
                    case CMD_JUDGEOBJ:
                    case CMD_GROUPOBJ:
                    case CMD_TRIXIEHOLD:
                    case CMD_PHOENIXHOLD:
                    case CMD_PHOENIXTAKE:
                        this.playVoice(cmd);
                        break;

                    // Testimony/Cross-examination commands
                    case CMD_ADDTEST:
                    case CMD_OBJECTHERE:
                        // Add current story index to testimony array only when not in testimony mode
                        if (this.testimonyMode === 0) {
                            // Only add if not already in testimony mode
                            // Check if this line is already in the testimony array
                            if (!this.testimonyArray.includes(this.storyIndex)) {
                                this.testimonyArray.push(this.storyIndex);
                                this.maxTestimony = this.testimonyArray.length;
                                console.log(`Added testimony line ${this.storyIndex}, total: ${this.maxTestimony}`);
                            }
                            this.currentTestimony = this.maxTestimony - 2;  // -2 so it advances to the new one
                            setTimeout(() => this.advanceStory(), 10);
                            return;
                        }
                        // If already in testimony mode, ignore the command and treat as normal story line
                        console.log(`Ignoring CMD_ADDTEST/CMD_OBJECTHERE in testimony mode ${this.testimonyMode}`);
                        break;
                        
                    case CMD_CLEARTEST:
                        this.testimonyArray = [];
                        this.maxTestimony = 0;
                        break;

                    case CMD_BADOBJECT:
                        // Set target for bad objection
                        this.badObjectTarget = storyLine.evidence;
                        console.log(`Set bad object target: ${this.badObjectTarget}`);
                        setTimeout(() => this.advanceStory(), 10);
                        return;

                    case CMD_GOODOBJECT:
                        // Set target for good objection
                        this.goodObjectTarget = storyLine.evidence;
                        console.log(`Set good object target: ${this.goodObjectTarget}`);
                        setTimeout(() => this.advanceStory(), 10);
                        return;

                    case CMD_STARTTEST:
                        // Start testimony mode
                        this.testimonyMode = 1;
                        this.currentTestimony = 0;
                        this.postTestTarget = storyLine.evidence;
                        console.log(`Starting testimony mode, ${this.maxTestimony} lines`);
                        if (this.maxTestimony > 0) {
                            this.storyIndex = this.testimonyArray[this.currentTestimony];
                            this.processStoryLine(this.currentStoryData[this.storyIndex]);
                        }
                        return;

                    case CMD_STARTCROSS:
                        // Start cross-examination mode
                        this.testimonyMode = 2;
                        this.currentTestimony = 0;
                        this.postTestTarget = storyLine.evidence;
                        console.log(`Starting cross-examination mode, ${this.maxTestimony} lines`);
                        if (this.maxTestimony > 0) {
                            this.storyIndex = this.testimonyArray[this.currentTestimony];
                            this.processStoryLine(this.currentStoryData[this.storyIndex]);
                        }
                        return;

                    case CMD_CONCROSS:
                        // Continue cross-examination at next line
                        this.testimonyMode = 2;
                        this.postTestTarget = storyLine.evidence;
                        this.currentTestimony++;
                        console.log(`Continuing cross-examination, testimony ${this.currentTestimony}/${this.maxTestimony}`);
                        if (this.currentTestimony < this.maxTestimony) {
                            this.storyIndex = this.testimonyArray[this.currentTestimony];
                            this.processStoryLine(this.currentStoryData[this.storyIndex]);
                        } else {
                            // End of testimony - jump to post-test target
                            this.testimonyMode = 0;
                            this.jumpToTag(this.postTestTarget);
                        }
                        return;

                    // Miss system commands
                    case CMD_RESETMISS:
                        // Reset to default miss count and set target
                        this.missesLeft = DEFAULT_MISSES;
                        this.missesTarget = storyLine.evidence;
                        console.log(`Reset misses to ${DEFAULT_MISSES}, target: ${this.missesTarget}`);
                        setTimeout(() => this.advanceStory(), 10);
                        return;

                    case CMD_CLEARMISS:
                        // Clear misses to zero
                        this.missesLeft = 0;
                        console.log(`Cleared misses to 0`);
                        setTimeout(() => this.advanceStory(), 10);
                        return;

                    case CMD_STOREMISS:
                        // Store current miss count and clear
                        this.recallMisses = this.missesLeft;
                        this.missesLeft = 0;
                        console.log(`Stored ${this.recallMisses} misses, cleared to 0`);
                        setTimeout(() => this.advanceStory(), 10);
                        return;

                    case CMD_RECALLMISS:
                        // Recall stored miss count
                        this.missesLeft = this.recallMisses;
                        console.log(`Recalled misses to ${this.missesLeft}`);
                        setTimeout(() => this.advanceStory(), 10);
                        return;

                    case CMD_MISS:
                        // Subtract a miss and check for game over
                        this.missesLeft--;
                        console.log(`Miss! Misses left: ${this.missesLeft}`);
                        this.playSound(CMD_CRASHSFX);
                        this.flashMissDisplay(); // Flash the miss display
                        this.updateDisplay(); // Update miss display
                        if (this.missesLeft < 1) {
                            // Game over - jump to miss target
                            console.log(`Game over! Jumping to target: ${this.missesTarget}`);
                            setTimeout(() => this.jumpToTag(this.missesTarget), 500); // Delay to show flash
                        } else {
                            setTimeout(() => this.advanceStory(), 500); // Delay to show flash
                        }
                        return;

                    default:
                        console.warn("Command not supported:", cmd);
                }
                
                if (isSilentCommand) {
                    setTimeout(() => this.advanceStory(), 10);
                } else {
                    // Update button states based on current mode
                    if (this.testimonyMode === 1) {
                        this.updateButtonStates('testimony');
                    } else if (this.testimonyMode === 2) {
                        this.updateButtonStates('cross-examination');
                    } else {
                        this.updateButtonStates('story');
                    }
                }
            }

            jumpToTag(tag) {
                // Find the story line with the matching evidence tag
                for (let i = 0; i < this.currentStoryData.length; i++) {
                    if (this.currentStoryData[i].evidence === tag &&
                        (this.currentStoryData[i].cmdwho & 0xff) < CMD_VOICEENDLIST) {
                        this.storyIndex = i;
                        this.processStoryLine(this.currentStoryData[i]);
                        return;
                    }
                }
                console.warn("Jump target not found:", tag);
            }

            addPrompt(tagId, text) {
                if (this.prompts.length < 6) { // MAX_PROMPTS
                    this.prompts.push({
                        tagId: tagId,
                        text: text,
                        isRead: false
                    });
                }
            }

            changePrompt(tagId, text, frame) {
                for (let i = 0; i < this.prompts.length; i++) {
                    if (this.prompts[i].tagId == tagId) {
                        if (frame != 0) {
                            this.prompts[i].tagId = frame;
                        }
                        if (text != "") {
                            this.prompts[i].text = text;
                        }
                        break;
                    }
                }
            }

            showConversationMenu() {
                const conversationList = document.getElementById('conversationList');
                conversationList.innerHTML = '';

                let firstItem = null;

                for (let i = 0; i < this.prompts.length; i++) {
                    const prompt = this.prompts[i];
                    const item = document.createElement('div');
                    item.className = 'menu-item' + (prompt.isRead ? ' read' : '');
                    item.textContent = `${i + 1}. ${prompt.text}`;
                    item.tabIndex = 0; // Make focusable
                    item.onclick = () => this.selectConversation(i);
                    conversationList.appendChild(item);
                    if (!firstItem) firstItem = item;
                }

                this.conversationMenuEl.style.display = 'block';
                this.updateButtonStates('story'); // Refresh button states with menu active

                // Focus the first item
                if (firstItem) {
                    setTimeout(() => firstItem.focus(), 50); // Small delay to ensure menu is visible
                }
            }

            selectConversation(index) {
                if (index < this.prompts.length) {
                    this.prompts[index].isRead = true;
                    this.hideAllMenus();
                    this.updateButtonStates('story'); // Return to story mode
                    this.focusNextButton(); // Return focus to Next button
                    this.jumpToTag(this.prompts[index].tagId);
                }
            }

            whiteScreen() {
                const flash = document.createElement('div');
                flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:1000;';
                document.body.appendChild(flash);
                setTimeout(() => document.body.removeChild(flash), 500);
                this.playSound(CMD_ICRASHSFX);
            }

            playVoice(voiceId) {
                const fileName = this.getVoiceFileName(voiceId);
                if (!fileName) {
                    console.warn("Unknown voice command:", voiceId);
                    this.playSound(CMD_CRASHSFX); // Fallback sound for unknown voices
                    return;
                }

                console.log(`Playing voice: ${fileName}`);

                // Create and play audio
                const audio = new Audio(fileName);
                audio.volume = 0.8; // Slightly higher volume for voices

                audio.onerror = () => {
                    console.warn(`Failed to load voice: ${fileName}`);
                    this.playSound(CMD_CRASHSFX); // Fallback sound
                };

                audio.play().catch(error => {
                    console.warn(`Failed to play voice: ${fileName}`, error);
                    this.playSound(CMD_CRASHSFX); // Fallback sound
                });
            }

            advanceStory() {
                // If typewriter is active, skip to end
                if (this.typewriterActive) {
                    this.skipTypewriter();
                    return;
                }

                // Handle testimony/cross-examination mode navigation
                if (this.testimonyMode !== 0) {
                    this.currentTestimony++;
                    if (this.currentTestimony < this.maxTestimony) {
                        // Move to next testimony line
                        this.storyIndex = this.testimonyArray[this.currentTestimony];
                        this.processStoryLine(this.currentStoryData[this.storyIndex]);
                    } else {
                        // End of testimony - jump to post-test target and exit testimony mode
                        this.testimonyMode = 0;
                        this.jumpToTag(this.postTestTarget);
                    }
                    return;
                }

                if (!this.currentStoryData || this.storyIndex >= this.currentStoryData.length - 1) {
                    // End of story for this location
                    this.setText("End of current content. Press E for Evidence, or return to menu.");
                    return;
                }

                this.storyIndex++;
                this.processStoryLine(this.currentStoryData[this.storyIndex]);
            }

            flashScreen() {
                const flash = document.createElement('div');
                flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:1000;';
                document.body.appendChild(flash);
                setTimeout(() => document.body.removeChild(flash), 200);
                this.playSound(CMD_CRASHSFX);
            }

            flashMissDisplay() {
                // Flash the miss display when a miss occurs
                if (this.missesLeft >= 0) {
                    const nameEl = this.nameEl;
                    let flashCount = 0;
                    const maxFlashes = 6; // 3 complete flash cycles

                    const flashInterval = setInterval(() => {
                        if (flashCount >= maxFlashes) {
                            clearInterval(flashInterval);
                            return;
                        }

                        // Toggle between normal and flash colors
                        if (flashCount % 2 === 0) {
                            // Flash state - red background
                            nameEl.style.backgroundColor = '#f44';
                            nameEl.style.color = '#fff';
                        } else {
                            // Normal state
                            nameEl.style.backgroundColor = '#333';
                            nameEl.style.color = '#4af';
                        }

                        flashCount++;
                    }, 100); // Flash every 100ms
                }
            }

            blackScreen() {
                this.imageEl.style.display = 'none';
                this.currentImage = -1;
            }

            getSfxFileName(soundCmd) {
                // Map SFX commands to WAV files
                // Some use literal names, others are indexed
                const sfxMap = {
                    // Generated sound effects (indexed by command)
                    [CMD_HAMMERSFX]: 'sfx/hammer.wav',      // Hammer sound
                    [CMD_CHIMESFX]: 'sfx/chime.wav',        // Chime sound (for cmd_stopmus)
                    [CMD_BOOMSFX]: 'sfx/boom.wav',          // Boom sound
                    [CMD_LOCKSFX]: 'sfx/psychelock.wav',    // 3 booms for psyche-locks
                    [CMD_BREAKSFX]: 'sfx/breaklock.wav',    // Break psyche-lock sfx
                    [CMD_PARTYSFX]: 'sfx/party.wav',        // Party horn sfx
                    [CMD_JOKESFX]: 'sfx/rimshot.wav',       // Rimshot sfx
                    [CMD_CRASHSFX]: 'sfx/crash.wav',        // Crash sfx
                    [CMD_ICRASHSFX]: 'sfx/icrash.wav',      // Inverted crash sfx (used by CMD_WHITE)
                    [CMD_RIPSFX]: 'sfx/rip.wav',            // Rip sfx
                    [CMD_WHOOSHSFX]: 'sfx/whoosh.wav',      // Whoosh sfx
                    [CMD_FALLSFX]: 'sfx/fall.wav',          // Falling sfx
                    [CMD_MAGICSFX]: 'sfx/magic.wav',        // Magic sfx
                    [CMD_BADMAGSFX]: 'sfx/badmagic.wav',    // Bad magic sfx
                    [CMD_SQUEAKSFX]: 'sfx/squeak.wav'       // Squeak sfx
                };

                return sfxMap[soundCmd] || null;
            }

            getVoiceFileName(voiceCmd) {
                // Map voice commands to WAV files (indexed)
                const voiceMap = {
                    // Voice clips (indexed S0-S8)
                    [CMD_TRIXIEOBJ]: 'sfx/S0.wav',       // Trixie objection
                    [CMD_PHOENIXOBJ]: 'sfx/S1.wav',      // Phoenix objection
                    [CMD_TWIOBJ]: 'sfx/S2.wav',          // Twilight objection
                    [CMD_FLUTTEROBJ]: 'sfx/S3.wav',      // Fluttershy objection
                    [CMD_JUDGEOBJ]: 'sfx/S4.wav',        // Judge objection
                    [CMD_GROUPOBJ]: 'sfx/S5.wav',        // Group objection
                    [CMD_TRIXIEHOLD]: 'sfx/S6.wav',      // Trixie hold it
                    [CMD_PHOENIXHOLD]: 'sfx/S7.wav',     // Phoenix hold it
                    [CMD_PHOENIXTAKE]: 'sfx/S8.wav'      // Phoenix take that!
                };

                return voiceMap[voiceCmd] || null;
            }

            playSound(soundId) {
                const fileName = this.getSfxFileName(soundId);
                if (!fileName) {
                    console.warn("Unknown sound command:", soundId);
                    return;
                }

                console.log(`Playing sound: ${fileName}`);

                // Create and play audio
                const audio = new Audio(fileName);
                audio.volume = 0.7; // Slightly lower volume for SFX

                audio.onerror = () => {
                    console.warn(`Failed to load sound: ${fileName}`);
                };

                audio.play().catch(error => {
                    console.warn(`Failed to play sound: ${fileName}`, error);
                });
            }

            getMusicIndex(musicCmd) {
                // Map music commands to indexes starting from CMD_MUSSTEEL as index 1
                // These indexes must match the original CMD_MUSTARTLIST order from structures.h
                const musicMap = {
                    [CMD_MUSSTEEL]: 1,      // Steel Samurai Ringtone
                    [CMD_MUSSTART]: 2,      // Apollo Justice - Start of a New Trial!
                    [CMD_MUSEXAM]: 3,       // Cross Examination - Moderate 2007
                    [CMD_MUSCROSS]: 4,      // Cross Examination - Moderato 2002
                    [CMD_MUSTRICK]: 5,      // Magic and Tricks
                    [CMD_MUSMLP]: 6,        // My Little Pony - Friendship is Magic Theme (8-bit)
                    [CMD_MUSTROUPE]: 7,     // Gramarye Troupe
                    [CMD_MUSTRIAL]: 8,      // Ace Attorney 4 - Trial
                    [CMD_MUSTRANCE]: 9,     // Trance Logic
                    [CMD_MUSPEARLY]: 10,    // With Pearly
                    [CMD_MUSSISTER]: 11,    // Turnabout Sisters
                    [CMD_MUSSMILE]: 12,     // Smile Instrumental
                    [CMD_MUSLOCK]: 13,      // Lock on the Heart
                    [CMD_MUSTRIALS]: 14,    // Trials and Tribulation WiiWare Rips
                    [CMD_MUSPROLOG]: 15,    // Apollo Justice - Prologue
                    [CMD_MUSECHESS]: 16,    // Logic Chess End - Moderato
                    [CMD_MUSOBJECT]: 17,    // Objection! 2009
                    [CMD_MUSTHRILL]: 18,    // Thrill Theme - Suspense
                    [CMD_MUSINTEREST]: 19,  // Interesting People
                    [CMD_MUSTRAGIC]: 20,    // Interview Tragicomedy
                    [CMD_MUSMIDDLE]: 21,    // Investigation Middlegame
                    [CMD_MUSKG8]: 22,       // KG-8 Case
                    [CMD_MUSLYING]: 23,     // Lying Coldly
                    [CMD_MUSMOON]: 24,      // Moonlight Sonata
                    [CMD_MUSWINTER]: 25,    // Winter Wrap Up
                    [CMD_MUSLOUNGE]: 26,    // Courtroom Lounge
                    [CMD_MUSHOTLINE]: 27,   // Hotline to Destiny
                    [CMD_MUSSUSPENSE]: 28,  // Suspense
                    [CMD_MUSBEGIN]: 29,     // Court Begins
                    [CMD_MUSTRUTH]: 30,     // Tell the Truth 2002
                    [CMD_MUSPURSUIT]: 31,   // Pursuit - Questioned
                    [CMD_MUSEND]: 32,       // Ace Attorney ~ End
                    [CMD_MUSCORNERED]: 33,  // Pursuit Cornered 2001
                    [CMD_MUSSWEPT]: 34,     // Sweptaway Turnabout
                    [CMD_MUSCORE]: 35,      // Investigation Core 2001
                    [CMD_MUSPRELUDE]: 36,   // Unending Prelude
                    [CMD_MUSGIGGLE]: 37,    // Giggle at the Ghosties
                    [CMD_MUSCOURT]: 38,     // Court Begins Orchestrated
                    [CMD_MUSWON]: 39,       // Won the Lawsuit
                    [CMD_MUSAJ]: 40,        // Applejack's Theme
                    [CMD_MUSRARITY]: 41,    // Rarity's Theme
                    [CMD_MUSTRUCY]: 42,     // Trucy's Theme
                    [CMD_MUSELEGY]: 43,     // Guard's elegy
                    [CMD_MUSGUILTY]: 44,    // Guilty love
                    [CMD_MUSRECALL]: 45,    // Recollation
                    [CMD_MUSCRUSADE]: 46,   // Crusading (Apple Bloom)
                    [CMD_MUSCLOCK]: 47,     // Like Clockwork (Sonata)
                    [CMD_MUSSPECIAL]: 48,   // Special Delivery! (Derpy)
                    [CMD_MUSCOOL]: 49,      // Too Cool For You, Dweeb (Gilda)
                    [CMD_MUSMEMORY]: 50,    // Memories (Gilda confession)
                    [CMD_MUSSCHESS]: 51,    // Logic Chess Start - Moderato
                    [CMD_MUSOBJECT2]: 52,   // Objection! 2011
                    [CMD_MUSOBJECT3]: 53,   // Objection! 2002
                    [CMD_MUSFALL]: 54       // Shiru - Fall of the Leaf
                };

                return musicMap[musicCmd] || 0;
            }

            playMusic(musicId) {
                const musicIndex = this.getMusicIndex(musicId);
                if (musicIndex === 0) {
                    console.warn("Unknown music command:", musicId);
                    return;
                }

                // Stop current music if playing
                this.stopMusic();

                // Load and play new music
                const paddedIndex = musicIndex.toString().padStart(2, '0');
                const musicUrl = `mp3/M${paddedIndex}.mp3`;

                console.log(`Playing music: ${musicUrl} (command ${musicId})`);

                this.musicAudio = new Audio(musicUrl);
                this.musicAudio.loop = true; // Most game music should loop
                this.currentMusic = musicId;

                // Handle music load errors
                this.musicAudio.onerror = () => {
                    console.warn(`Failed to load music: ${musicUrl}`);
                    this.musicAudio = null;
                    this.currentMusic = null;
                };

                // Play the music
                this.musicAudio.play().catch(error => {
                    console.warn(`Failed to play music: ${musicUrl}`, error);
                });
            }

            stopMusic() {
                if (this.musicAudio) {
                    this.musicAudio.pause();
                    this.musicAudio.currentTime = 0;
                    this.musicAudio = null;
                }
                this.currentMusic = null;
                console.log("Music stopped");
            }
        }

        // Initialize the game when page loads
        let game;
        window.onload = () => {
            game = new PhoenixWrightGame();
        };
    </script>
</body>
</html>